<title>Reading from and writing to files</title>

<h1>Description</h1>
<ul>
<li><b>class : </b><code>Yuni::Core::IO::File::Stream</code></li>
<li><b>include : </b><code>&lt;yuni/core/io/file.h&gt;</code></li>
</ul>
<p>
The class <code>Core::IO::File::Stream</code> provides an independent platform
interface for reading from and writing to files.
All filenames passed to this interface must be UTF-8 encoded. This class can be
used as a data stream (like <code>Yuni::String</code> or <code>std::cout</code>).
Contrary to some other implementations, this class reads and writes data 'as it'.
That means that no conversion is performed when reading or writing.
</p>
<p>
A file is opened with <code>open</code> (or directly from the constructor). Data is
usually read with <code>read</code> or <code>readline</code>. Writing to the file
is the same as writing to a data stream. Closing a file is implicit. It is
automatically closed at the destruction of the object or when another file
is opened.
</p>


<h1>Reading from a file</h1>

<h2>Reading Raw data files</h2>
<p>
This example reads each file given from the command line and write them to the
console (<code>std::cout</code>).
</p>
<source type="cpp">
#include &lt;yuni/yuni.h&gt;
#include &lt;yuni/core/io/file.h&gt;
#include &lt;iostream&gt;


int main(int argc, char** argv)
{
	if (argc &lt;= 1)
		return 0;

	// We will read our file chunk by chunk (4K for each chunk)
	Yuni::CustomString&lt;4096&gt; buffer;

	// For each filename given from the command line
	for (int i = 1; i &lt; argc; ++i)
	{
		// The filename to read
		const char* filename = argv[i];

		Yuni::Core::IO::File::Stream file;
		if (file.open(filename))
		{
			std::cout &lt;&lt; "reading " &lt;&lt; filename &lt;&lt; std::endl;
			while (file.read(buffer))
				std::cout &lt;&lt; buffer; // Writing it to the standard output

			// We have reached the end of the file
			std::cout &lt;&lt; std::endl;
		}
		else
			std::cout &lt;&lt; "!! impossible to open " &lt;&lt; filename &lt;&lt; std::endl;
	}
	return 0;
}
</source>


<h2>Reading from a file line by line</h2>
<p>
This exemple is the same as before, except we will read the file line by line
and printing the line number in the same time.
</p>
<source type="cpp">
#include &lt;yuni/yuni.h&gt;
#include &lt;yuni/core/io/file.h&gt;
#include &lt;iostream&gt;


int main(int argc, char** argv)
{
	if (argc &lt;= 1)
		return 0;

	// We will read our file chunk by chunk (4K for each chunk)
	Yuni::CustomString&lt;4096&gt; line;

	for (int i = 1; i &lt; argc; ++i)
	{
		// The filename to read
		const char* filename = argv[i];

		Yuni::Core::IO::File::Stream file;
		if (file.open(filename))
		{
			std::cout &lt;&lt; "reading " &lt;&lt; filename &lt;&lt; std::endl;
			unsigned int line = 0;
			while (file.readline(line))
				std::cout &lt;&lt; (++line) &lt;&lt; ": " &lt;&lt; buffer;

			// We have reached the end of the file
			std::cout &lt;&lt; std::endl;
		}
		else
			std::cout &lt;&lt; "!! impossible to open " &lt;&lt; filename &lt;&lt; std::endl;
	}
	return 0;
}
</source>



<h1>Writing to a file</h1>
<p>
Writing to a file is as simple as writing to any data stream.
This exemple will write <code>"Hello world !\n"</code> to a filename given from the command line.
</p>
<source>
#include &lt;yuni/yuni.h&gt;
#include &lt;yuni/core/io/file.h&gt;
#include &lt;iostream&gt;


int main(int argc, char** argv)
{
	if (argv &lt;= 1)
		return 0;

	// The filename where to write some data
	const char* filename = argv[1];

	Yuni::Core::IO::File::Stream file;
	// Trying to open the filename in read/write mode. If the file exists it will
	// be truncated.
	if (file.openRW(filename))
	{
		file &lt;&lt; "Hello world !\n";
	}
	else
		std::cout &lt;&lt; "impossible to write " &lt;&lt; filename &lt;&lt; std::endl;
	return 0;
}
</source>
<p>
Any datatype that a <code>Yuni::String</code> understands can be used here.
</p>



