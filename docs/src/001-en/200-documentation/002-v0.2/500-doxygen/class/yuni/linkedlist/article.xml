<title>LinkedList</title>
<pragma:weight value="0.5" />
<tag name="doxygen" />
<tag name="class" />



<h2>Summary of the class <code>LinkedList</code></h2><table class="nostyle">
<tr><td><div class="visibility">Public</div></td>
<td><h3 class="h3noleftspace">Constructors &amp; Destructor</h3>
<p class="doxygen_fun">Default Constructor.<br />
<code> <span class="method"><a href="#">LinkedList</a></span>();</code></p>
<p class="doxygen_fun">Copy constructor.<br />
<code> <span class="method"><a href="#">LinkedList</a></span>(const LinkedList<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Copy constructor from another linked list.<br />
<code><span class="keyword">template</span>&lt;class U , class A &gt;<br /> <span class="method"><a href="#">LinkedList</a></span>(const LinkedList &lt; U, A &gt;<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Copy constructor from a standard std::list.<br />
<code><span class="keyword">template</span>&lt;class U , class A &gt;<br /> <span class="method"><a href="#">LinkedList</a></span>(const std::list&lt; U, A &gt;<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Copy constructor from a standard std::vector.<br />
<code><span class="keyword">template</span>&lt;class U , class A &gt;<br /> <span class="method"><a href="#">LinkedList</a></span>(const std::vector&lt; U, A &gt;<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Destructor.<br />
<code> <span class="method"><a href="#"><b> ~ </b>LinkedList</a></span>();</code></p>
</td></tr>
<tr><td><div class="visibility">Public</div></td>
<td><h3 class="h3noleftspace">Iterators &amp; Accessors</h3>
<p class="doxygen_fun">Get an iterator at the beginning of the list.<br />
<code>iterator <span class="method"><a href="#">begin</a></span>();</code></p>
<p class="doxygen_fun">Get an iterator at the beginning of the list.<br />
<code>const_iterator <span class="method"><a href="#">begin</a></span>() <span class="keyword">const</span>;</code></p>
<p class="doxygen_fun">Get an iterator at the end of the list.<br />
<code>iterator <span class="method"><a href="#">end</a></span>();</code></p>
<p class="doxygen_fun">Get an iterator at the beginning of the list.<br />
<code>const_iterator <span class="method"><a href="#">end</a></span>() <span class="keyword">const</span>;</code></p>
<p class="doxygen_fun">Get the first item.<br />
<code>reference_type <span class="method"><a href="#">front</a></span>();</code></p>
<p class="doxygen_fun">Get an iterator at the beginning of the list.<br />
<code>const_reference_type <span class="method"><a href="#">front</a></span>() <span class="keyword">const</span>;</code></p>
<p class="doxygen_fun">Get the last item.<br />
<code>reference_type <span class="method"><a href="#">back</a></span>();</code></p>
<p class="doxygen_fun">Get an iterator at the beginning of the list.<br />
<code>const_reference_type <span class="method"><a href="#">back</a></span>() <span class="keyword">const</span>;</code></p>
</td></tr>
<tr><td><div class="visibility">Public</div></td>
<td><h3 class="h3noleftspace">Find</h3>
<p class="doxygen_fun">Get the first item equal to a given value.<br />
<code><span class="keyword">template</span>&lt;class U &gt;<br />iterator <span class="method"><a href="#">find</a></span>(const U<b>&amp;</b> value);</code></p>
<p class="doxygen_fun">Get the first item equal to a given value.<br />
<code>iterator <span class="method"><a href="#">find</a></span>(const_reference_type value);</code></p>
<p class="doxygen_fun">Get the first item equal to a given value.<br />
<code><span class="keyword">template</span>&lt;class U &gt;<br />const_iterator <span class="method"><a href="#">find</a></span>(const U<b>&amp;</b> value) <span class="keyword">const</span>;</code></p>
<p class="doxygen_fun">Get the first item equal to a given value.<br />
<code>const_iterator <span class="method"><a href="#">find</a></span>(const_reference_type value) <span class="keyword">const</span>;</code></p>
</td></tr>
<tr><td><div class="visibility">Public</div></td>
<td><h3 class="h3noleftspace">Add</h3>
<p class="doxygen_fun">Add a value at the end of the list (default constructor)<br />
<code>void <span class="method"><a href="#">push_back</a></span>();</code></p>
<p class="doxygen_fun">Add a value at the end of the list.<br />
<code><span class="keyword">template</span>&lt;class U &gt;<br />void <span class="method"><a href="#">push_back</a></span>(const U<b>&amp;</b> value);</code></p>
<p class="doxygen_fun">Add a value at the end of the list (default constructor)<br />
<code>void <span class="method"><a href="#">push_back</a></span>(reference_type value);</code></p>
<p class="doxygen_fun">Add a list of values at the end of the list.<br />
<code><span class="keyword">template</span>&lt;class U , class A &gt;<br />void <span class="method"><a href="#">push_back</a></span>(const LinkedList &lt; U, A &gt;<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Add a list of values at the end of the list.<br />
<code><span class="keyword">template</span>&lt;class U , class A &gt;<br />void <span class="method"><a href="#">push_back</a></span>(const std::list&lt; U, A &gt; rhs);</code></p>
<p class="doxygen_fun">Add a list of values at the end of the list.<br />
<code><span class="keyword">template</span>&lt;class U , class A &gt;<br />void <span class="method"><a href="#">push_back</a></span>(const std::vector&lt; U, A &gt;<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Add a value at the beginning of the list (default constructor)<br />
<code>void <span class="method"><a href="#">push_front</a></span>();</code></p>
<p class="doxygen_fun">Add a value at the begining of the list.<br />
<code><span class="keyword">template</span>&lt;class U &gt;<br />void <span class="method"><a href="#">push_front</a></span>(const U<b>&amp;</b> value);</code></p>
<p class="doxygen_fun">Add a value at the end of the list (default constructor)<br />
<code>void <span class="method"><a href="#">push_front</a></span>(reference_type value);</code></p>
<p class="doxygen_fun">Add a list of values at the beginning of the list.<br />
<code><span class="keyword">template</span>&lt;class U , class A &gt;<br />void <span class="method"><a href="#">push_front</a></span>(const LinkedList &lt; U, A &gt;<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Add a list of values at the beginning of the list.<br />
<code><span class="keyword">template</span>&lt;class U , class A &gt;<br />void <span class="method"><a href="#">push_front</a></span>(const std::list&lt; U, A &gt;<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Add a list of values at the beginning of the list.<br />
<code><span class="keyword">template</span>&lt;class U , class A &gt;<br />void <span class="method"><a href="#">push_front</a></span>(const std::vector&lt; U, A &gt;<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Remove the first element.<br />
<code>void <span class="method"><a href="#">pop_front</a></span>();</code></p>
</td></tr>
<tr><td><div class="visibility">Public</div></td>
<td><h3 class="h3noleftspace">Remove</h3>
<p class="doxygen_fun">Remove the item pointed to by the iterator.<br />
<code>void <span class="method"><a href="#">erase</a></span>(iterator<b>&amp;</b> i);</code></p>
<p class="doxygen_fun">Remove any item equal to a given value.<br />
<code><span class="keyword">template</span>&lt;class U &gt;<br />Size <span class="method"><a href="#">remove</a></span>(const U<b>&amp;</b> value);</code></p>
<p class="doxygen_fun">Remove the item pointed to by the iterator.<br />
<code>Size <span class="method"><a href="#">remove</a></span>(reference_type value);</code></p>
<p class="doxygen_fun">Remove any item equal to a value in the given list.<br />
<code><span class="keyword">template</span>&lt;class U , class A &gt;<br />Size <span class="method"><a href="#">remove</a></span>(const LinkedList &lt; U, A &gt;<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Remove any item equal to a value in the given list.<br />
<code><span class="keyword">template</span>&lt;class U , class A &gt;<br />Size <span class="method"><a href="#">remove</a></span>(const std::list&lt; U, A &gt;<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Remove any item equal to a value in the given list.<br />
<code><span class="keyword">template</span>&lt;class U , class A &gt;<br />Size <span class="method"><a href="#">remove</a></span>(const std::vector&lt; U, A &gt;<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Remove all items at once.<br />
<code>void <span class="method"><a href="#">clear</a></span>();</code></p>
</td></tr>
<tr><td><div class="visibility">Public</div></td>
<td><h3 class="h3noleftspace">Memory</h3>
<p class="doxygen_fun">Get if the container is empty.<br />
<code>bool <span class="method"><a href="#">empty</a></span>() <span class="keyword">const</span>;</code></p>
<p class="doxygen_fun">Get if the container is not empty.<br />
<code>bool <span class="method"><a href="#">notEmpty</a></span>() <span class="keyword">const</span>;</code></p>
<p class="doxygen_fun">Get the number of items in the container.<br />
<code>Size <span class="method"><a href="#">size</a></span>() <span class="keyword">const</span>;</code></p>
</td></tr>
<tr><td><div class="visibility">Public</div></td>
<td><h3 class="h3noleftspace">Operators</h3>
<p class="doxygen_fun">Clear then add the value.<br />
<code>LinkedList &amp; <span class="method"><a href="#">operator=</a></span>(const LinkedList<b>&amp;</b> value);</code></p>
<p class="doxygen_fun">Append a new item at the end of the list.<br />
<code><span class="keyword">template</span>&lt;class U &gt;<br />LinkedList &amp; <span class="method"><a href="#">operator+=</a></span>(const U<b>&amp;</b> value);</code></p>
<p class="doxygen_fun">Append a new item at the end of the list.<br />
<code><span class="keyword">template</span>&lt;class U &gt;<br />LinkedList &amp; <span class="method"><a href="#">operator&lt;&lt;</a></span>(const U<b>&amp;</b> value);</code></p>
<p class="doxygen_fun">Remove all items equal to 'value'.<br />
<code><span class="keyword">template</span>&lt;class U &gt;<br />LinkedList &amp; <span class="method"><a href="#">operator-=</a></span>(const U<b>&amp;</b> value);</code></p>
<p class="doxygen_fun">Check if the container is empty.<br />
<code>bool <span class="method"><a href="#">operator!</a></span>() <span class="keyword">const</span>;</code></p>
</td></tr>
<tr><td><div class="visibility">Protected
</div></td>
<td><h3 class="h3noleftspace">Protected
</h3>
<p>Indicates whether to base the comparison between values on a dereferenced pointer.<br />
<code><i>(unmanaged tag)</i></code></p>
</td></tr>
<tr><td><div class="visibility">Public
</div></td>
<td><h3 class="h3noleftspace">Public
</h3>
<p class="doxygen_typedef">Size type.<br />
<code><span class="keyword">typedef</span> unsigned int <span class="method"><a href="#">Size</a></span>;</code></p>
<p class="doxygen_typedef">Size type (STL compliant)<br />
<code><span class="keyword">typedef</span> Size <span class="method"><a href="#">size_type</a></span>;</code></p>
<p class="doxygen_typedef">Value type.<br />
<code><span class="keyword">typedef</span> T <span class="method"><a href="#">Type</a></span>;</code></p>
<p class="doxygen_typedef">Value type.<br />
<code><span class="keyword">typedef</span> T <span class="method"><a href="#">ValueType</a></span>;</code></p>
<p class="doxygen_typedef">Value type (STL compliant)<br />
<code><span class="keyword">typedef</span> T <span class="method"><a href="#">value_type</a></span>;</code></p>
<p class="doxygen_typedef">Reference.<br />
<code><span class="keyword">typedef</span> T &amp; <span class="method"><a href="#">reference_type</a></span>;</code></p>
<p class="doxygen_typedef">Reference (const)<br />
<code><span class="keyword">typedef</span> const T &amp; <span class="method"><a href="#">const_reference_type</a></span>;</code></p>
<p class="doxygen_typedef">Pointer.<br />
<code><span class="keyword">typedef</span> T * <span class="method"><a href="#">pointer_type</a></span>;</code></p>
<p class="doxygen_typedef">Pointer (const)<br />
<code><span class="keyword">typedef</span> const T * <span class="method"><a href="#">const_pointer_type</a></span>;</code></p>
<p class="doxygen_typedef">Iterator (STL compliant)<br />
<code><span class="keyword">typedef</span> IIterator &lt; Iterator , false &gt; <span class="method"><a href="#">iterator</a></span>;</code></p>
<p class="doxygen_typedef"><code><span class="keyword">typedef</span> IIterator &lt; Iterator , true &gt; <span class="method"><a href="#">const_iterator</a></span>;</code></p>
</td></tr>
<tr><td><div class="visibility">Protected
</div></td>
<td><h3 class="h3noleftspace">Protected
</h3>
<p class="doxygen_var">The head of the list.<br />
<code>Item * <span class="method"><a href="#">pHead</a></span>;</code></p>
<p class="doxygen_var">The last item in the list.<br />
<code>Item * <span class="method"><a href="#">pLast</a></span>;</code></p>
<p class="doxygen_var">Item count.<br />
<code>unsigned int <span class="method"><a href="#">pCount</a></span>;</code></p>
</td></tr>
<tr><td><div class="visibility">Protected
</div></td>
<td><h3 class="h3noleftspace">Protected
</h3>
<p class="doxygen_fun">Internal clear (without resetting values)<br />
<code>void <span class="method"><a href="#">doClear</a></span>();</code></p>
</td></tr>
</table>


<h2>Detailed Description</h2>
