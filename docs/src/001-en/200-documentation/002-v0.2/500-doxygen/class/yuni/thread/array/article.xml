<title>Array</title>
<pragma:weight value="0.5" />
<tag name="doxygen" />
<tag name="class" />



<h2>Summary of the class <code>Array</code></h2><table class="nostyle">
<tr><td><div class="visibility">Public</div></td>
<td><h3 class="h3noleftspace">Constructor</h3>
<p class="doxygen_fun">Default Constructor.<br />
<code> <span class="method"><a href="#">Array</a></span>();</code></p>
<p class="doxygen_fun">Copy constructor.<br />
<code> <span class="method"><a href="#">Array</a></span>(const Array<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Constructor with a given amount of thread.<br />
<code> <span class="method"><a href="#">Array</a></span>(unsigned int n);</code></p>
<p class="doxygen_fun">Constructor, with a given amount of thread.<br />
<code> <span class="method"><a href="#">Array</a></span>(unsigned int n, bool autoStart);</code></p>
<p class="doxygen_fun">Destructor.<br />
<code> <span class="method"><a href="#"><b> ~ </b>Array</a></span>();</code></p>
</td></tr>
<tr><td><div class="visibility">Public</div></td>
<td><h3 class="h3noleftspace">Settings</h3>
<p class="doxygen_fun">Get if the new thread are automatically started.<br />
<code>bool <span class="method"><a href="#">autoStart</a></span>() <span class="keyword">const</span>;</code></p>
<p class="doxygen_fun">Set if the new thread are automatically started.<br />
<code>void <span class="method"><a href="#">autoStart</a></span>(const bool v);</code></p>
</td></tr>
<tr><td><div class="visibility">Public</div></td>
<td><h3 class="h3noleftspace">Operators</h3>
<p class="doxygen_fun">Get the pointer to a specific thread.<br />
<code>T::Ptr <span class="method"><a href="#">operator[]</a></span>(unsigned int index) <span class="keyword">const</span>;</code></p>
<p class="doxygen_fun">Copy operator.<br />
<code>Array &amp; <span class="method"><a href="#">operator=</a></span>(const Array<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Copy operator.<br />
<code>Array &amp; <span class="method"><a href="#">operator=</a></span>(const Ptr<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Aggregate.<br />
<code>Array &amp; <span class="method"><a href="#">operator+=</a></span>(const Array<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Aggregate.<br />
<code>Array &amp; <span class="method"><a href="#">operator+=</a></span>(T<b>*</b> rhs);</code></p>
<p class="doxygen_fun">Aggregate.<br />
<code>Array &amp; <span class="method"><a href="#">operator+=</a></span>(const typename T::Ptr<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Aggregate.<br />
<code>Array &amp; <span class="method"><a href="#">operator+=</a></span>(const Ptr<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Aggregate.<br />
<code>Array &amp; <span class="method"><a href="#">operator&lt;&lt;</a></span>(const Array<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Aggregate.<br />
<code>Array &amp; <span class="method"><a href="#">operator&lt;&lt;</a></span>(const Ptr<b>&amp;</b> rhs);</code></p>
<p class="doxygen_fun">Aggregate.<br />
<code>Array &amp; <span class="method"><a href="#">operator&lt;&lt;</a></span>(T<b>*</b> rhs);</code></p>
<p class="doxygen_fun">Aggregate.<br />
<code>Array &amp; <span class="method"><a href="#">operator&lt;&lt;</a></span>(const typename T::Ptr<b>&amp;</b> rhs);</code></p>
</td></tr>
<tr><td><div class="visibility">Public
</div></td>
<td><h3 class="h3noleftspace">Public
</h3>
<p>A hard limit value for the number of threads in the pool.<br />
<code><i>(unmanaged tag)</i></code></p>
<p class="doxygen_typedef">Itself.<br />
<code><span class="keyword">typedef</span> Array &lt; T &gt; <span class="method"><a href="#">ArrayType</a></span>;</code></p>
<p class="doxygen_typedef">The most suitable smart pointer.<br />
<code><span class="keyword">typedef</span> SmartPtr &lt; ArrayType &gt; <span class="method"><a href="#">Ptr</a></span>;</code></p>
<p class="doxygen_typedef">Thread .<br />
<code><span class="keyword">typedef</span> T <span class="method"><a href="#">ThreadType</a></span>;</code></p>
<p class="doxygen_typedef">Smart Pointer for the thread.<br />
<code><span class="keyword">typedef</span> T::Ptr <span class="method"><a href="#">ThreadPtr</a></span>;</code></p>
<p class="doxygen_typedef">Threading Policy .<br />
<code><span class="keyword">typedef</span> Policy::ObjectLevelLockable &lt; ArrayType &gt; <span class="method"><a href="#">ThreadingPolicy</a></span>;</code></p>
<p class="doxygen_typedef">Thread list.<br />
<code><span class="keyword">typedef</span> std::vector&lt; typename T::Ptr &gt; <span class="method"><a href="#">ThreadList</a></span>;</code></p>
<p>Get if this policy is thread-safe.<br />
<code><i>(unmanaged tag)</i></code></p>
</td></tr>
<tr><td><div class="visibility">Public
</div></td>
<td><h3 class="h3noleftspace">Public
</h3>
<p class="doxygen_fun">Clear the pool (remove all threads)<br />
<code>void <span class="method"><a href="#">clear</a></span>();</code></p>
<p class="doxygen_fun">Add an existing thread into the container.<br />
<code>void <span class="method"><a href="#">add</a></span>(typename T::Ptr thread);</code></p>
<p class="doxygen_fun">Add an existing thread into the container.<br />
<code>void <span class="method"><a href="#">add</a></span>(typename T::Ptr thread, bool autostart);</code></p>
<p class="doxygen_fun"><code>void <span class="method"><a href="#">push_back</a></span>(typename T::Ptr thread);</code></p>
<p class="doxygen_fun">Resize the pool.<br />
<code>void <span class="method"><a href="#">resize</a></span>(unsigned int n);</code></p>
<p class="doxygen_fun">Start all threads.<br />
<code>void <span class="method"><a href="#">start</a></span>();</code></p>
<p class="doxygen_fun">Ask to all threads to stop their execution as soon as possible.<br />
<code>void <span class="method"><a href="#">gracefulStop</a></span>();</code></p>
<p class="doxygen_fun">Stop all threads.<br />
<code>void <span class="method"><a href="#">stop</a></span>(unsigned int timeout);</code></p>
<p class="doxygen_fun">Restart all threads.<br />
<code>void <span class="method"><a href="#">restart</a></span>(unsigned int timeout);</code></p>
<p class="doxygen_fun">Wake up all threads.<br />
<code>void <span class="method"><a href="#">wakeUp</a></span>();</code></p>
<p class="doxygen_fun">Get the number of threads.<br />
<code>unsigned int <span class="method"><a href="#">size</a></span>() <span class="keyword">const</span>;</code></p>
<p class="doxygen_fun"><code>unsigned int <span class="method"><a href="#">count</a></span>() <span class="keyword">const</span>;</code></p>
<p class="doxygen_fun">Get if the array is empty.<br />
<code>bool <span class="method"><a href="#">empty</a></span>() <span class="keyword">const</span>;</code></p>
<p class="doxygen_fun">Execute a predicate for each thread in pool.<br />
<code><span class="keyword">template</span>&lt;class PredicateT &gt;<br />void <span class="method"><a href="#">foreachThread</a></span>(PredicateT<b>&amp;</b> predicate) <span class="keyword">const</span>;</code></p>
</td></tr>
<tr><td><div class="visibility">Protected
</div></td>
<td><h3 class="h3noleftspace">Protected
</h3>
<p class="doxygen_var">Mutex.<br />
<code>Mutex <span class="method"><a href="#">pMutex</a></span>;</code></p>
</td></tr>
</table>


<h2>Detailed Description</h2>
