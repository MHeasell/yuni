<title>Observer</title>
<pragma:weight value="0.5" />
<pragma:toc visible="false" />
<tag name="doxygen" />
<tag name="dox:class" />



<h2>Observer (Base class)<br /> Only classes derived from the class `Observer` can pretend to receive signals from an event. This is due to the fact that there is a strong relationship between the emitter and the receiver, to prevent the corruption of pointers.<br /></h2>
<div>The class uses the CRTP (Curiously recurring template pattern) Idiom to broadcast the good type to the threading policy.<br /> The derived class *must* disconnect all event emitters as soon as possible when the instance is being destroyed to avoid race exceptions (the VTable may partially be deleted). The method `destroyingObserver()` prevents any further connection with an event emitter and must always be called at least from the destructor.<br /> A complete example using the threading policies :<source type="cpp">  #include  &lt;iostream&gt;
  #include  &lt; yuni/core/event.h &gt;


  template &lt; template &lt; class &gt;  class  TP  =  Policy::ObjectLevelLockable&gt;
  class  ThermalSensor  :  public  TP&lt;ThermalSensor&gt;
  {
  public :
         //!  The  threading  policy
         typedef  TP&lt;ThermalSensor&gt;   ThreadingPolicy ;

  public :
         ThermalSensor()  :pLastValue(0.)  {}
         ~ThermalSensor()  {}

         Event::E1&lt;void,  float,  TP&gt;  eventOnChanged;

         void  update( const  float  newT)
         {
             {
                 typename  ThreadingPolicy::MutexLocker  locker(* this );
                 if  (pLastValue  -  newT  &lt;  0.1f)
                     pLastValue  =  newT;
                 else
                     return ;
             }
             onChanged(newT);
         }

  private :
         float  pLastValue;
  };


  template &lt; template &lt; class &gt;  class  TP  =  Policy::ObjectLevelLockable&gt;
  class  Radiator  :  Event :: Observer &lt;Radiator&lt;TP&gt;,  TP&gt;
  {
  public :
         //!  The  threading  policy
         typedef  TP&lt;ThermalSensor&gt;   ThreadingPolicy ;

  public :
         Radiator( const  String &amp;  name,  const  float  limit)
             :pName(name),  pStarted(false),  pLimit(limit)
         {}

         ~Radiator()
         {
             destroyingObserver ();
         }

         String  name()
         {
             typename  ThreadingPolicy::MutexLocker  locker(* this );
             return  pName;
         }

         void  start()
         {
             typename  ThreadingPolicy::MutexLocker  locker(* this );
             if  (!pStarted)
             {
                 pStarted  =  true ;
                 std::cout  &lt;&lt;  "The  radiator  `"  &lt;&lt;  pName  &lt;&lt;  "`  has  started."  &lt;&lt;  std::endl;
             }
         }

         void  stop()
         {
             typename  ThreadingPolicy::MutexLocker  locker(* this );
             if  (pStarted)
             {
                 pStarted  =  false ;
                 std::cout  &lt;&lt;  "The  radiator  `"  &lt;&lt;  pName  &lt;&lt;  "`has  stopped."  &lt;&lt;  std::endl;
             }
         }

         void  onTemperatureChanged( float  t)
         {
             std::cout  &lt;&lt;  "Temperature:  "  &lt;&lt;  t  &lt;&lt;  std::endl;
             checkTemperature(t);
         }

         float  limit()  const  { return  pLimit;}
         void  limit( const  float  newL)  {pLimit  =  newL;}

  private :
         void  checkTemperature( float  t)
         {
             typename  ThreadingPolicy::MutexLocker  locker(* this );
             if  (t  &gt;=  pLimit)
             {
                 if  (pStarted)
                     stop();
             }
             else
             {
                 if  (!pStarted)
                     start();
             }
         }

  private :
         const  String  pName;
         bool  pStarted;
         float  pLimit;
  };


  int  main( void )
  {
         //  Our  thermal  sensor
         ThermalSensor&lt;&gt;  sensor;

         //  Our  observer
         Radiator&lt;&gt;  radiatorA( "A" ,  30.0);
         Radiator&lt;&gt;  radiatorB( "B" ,  16.0);
         sensor.eventOnChanged.connect(&amp;radiatorA,  &amp;Radiator::onTemperatureChanged);
         sensor.eventOnChanged.connect(&amp;radiatorB,  &amp;Radiator::onTemperatureChanged);

         sensor.update(-2.);
         sensor.update(10.1);
         sensor.update(15.9);
         sensor.update(22.7);
         sensor.update(42.);

         return  0;
  }
</source>
<br /><br />Parameters :<ul><li><code> D</code> The Derived class (CRTP)<br /></li><li><code> TP</code> The threading policy<br /></li></ul><br /></div>
<table class="doxygen_table">
<tr><td class="doxnone"></td><td class="doxnone"><h3 class="doxygen_section">Constructor &amp; Destructor <code class="doxygen_visibility">Public</code></h3>
</td></tr>
<tr><td class="doxygen_fun"></td><td class="doxnone"><div class="doxygen_brief">Default constructor.<br /><div class="doxygen_name_spacer"></div>
<code> <span class="method"><a href="javascript:toggleVisibility('Observer_67871319583276')">+ Observer</a></span>:  ();
</code>
</div></td></tr><tr id="Observer_67871319583276_desc" style="display:none"><td class="doxnone doxreturn"></td><td class="doxnone">
<div class="doxygen_name_spacer"></div>
<div class="doxygen_desc"><i>no description</i>
</div>
</td></tr>
<tr><td class="doxygen_fun"></td><td class="doxnone"><div class="doxygen_brief">Destructor.<br /><div class="doxygen_name_spacer"></div>
<code> <span class="method"><a href="javascript:toggleVisibility('~Observer_67881319583276')">+ <b> ~ </b>Observer</a></span>:  ();
</code>
</div></td></tr><tr id="~Observer_67881319583276_desc" style="display:none"><td class="doxnone doxreturn"></td><td class="doxnone">
<div class="doxygen_name_spacer"></div>
<div class="doxygen_desc"><i>no description</i>
</div>
</td></tr>
<tr><td class="doxnone"></td><td class="doxnone"><h3 class="doxygen_section">Public <code class="doxygen_visibility">Public</code></h3>
</td></tr>
<tr><td class="doxygen_typedef"></td><td class="doxnone"><div class="doxygen_brief">The threading policy.<br /><div class="doxygen_name_spacer"></div>
<code><span class="method"><a href="javascript:toggleVisibility('ThreadingPolicy_67891319583276')">+ ThreadingPolicy</a></span>: <span class="keyword">typedef</span> TP&lt; D&gt;;</code>
</div></td></tr><tr id="ThreadingPolicy_67891319583276_desc" style="display:none"><td class="doxnone doxreturn"></td><td class="doxnone">
<div class="doxygen_name_spacer"></div>
<div class="doxygen_desc"><i>no description</i>
</div>
</td></tr>
</table>


