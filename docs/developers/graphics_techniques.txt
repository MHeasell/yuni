
							Computer Graphics Techniques


I) Purpose of the document:
===========================

This document is a technical state of the art on computer graphics. The point
is to list known techniques, explain quickly how they work, and recognize each
of them's qualities and drawbacks, with a particular interest on performance,
memory usage and visual quality.

The second step in this approach is to identify, for each graphics feature,
which technique should be used depending on a given context. Each technique can
then be categorized as:
 A) Best quality is required, whatever the cost (not real-time).
 B) Good quality is required in real-time.
 C) Resources are very limited.
 D) Not interesting in any situation.


II) Techniques by feature:
==========================

  Shadows:
  --------

	0] No shadows:
	--------------
	How it works:
		Do nothing.
	Quality: Inexistent

	1] Shadow mapping:
	------------------
	How it works:
		Make a first render in Z-Buffer using the light as a camera.
		Objects failing the Z-test are in shadow
	Remarks:
		Not always very precise, creates hard shadows only, requires multiple
		passes, can induce shadow continuity glitches.
	Quality:
		Medium
	Speed:
		Fast
	Memory usage:
		Medium
			SCORE: C

	2] Shadow volumes with stencil buffering:
	-----------------------------------------
	How it works:
		Construct all the volumes of the scene that are in shadow.
		Use stencil buffer and Z-buffer to count the number of light/shadow
		faces crossed by the ray for each pixel.
	Remarks:
		There are adjustments to be made when the eye is in shadow.
		A technique exists to avoid the problem altogether, but it is patented.
	Quality:
		Good
	Speed:
		Low
	Memory usage:
		High
			SCORE: B

  Rendering:
  ----------

	1] Software rendering on triangle meshes:
    -----------------------------------------
	Quality: Low to Good
	Speed: Slow
			SCORE: D

	2] Hardware rendering on triangle meshes:
	-----------------------------------------
	Quality: Good
	Speed: Good
			SCORE: B + C

	3] Ray-tracing on vector-based geometry:
	----------------------------------------
	Quality: Best
	Speed: Very slow (not real-time)
			SCORE: A

  Bump-mapping:
  -------------

	0] No bump-mapping at all:
	--------------------------
	How it works:
		Do nothing.
	Quality: Low
	Speed: Best
		   Score: C

	1] Normal mapping (dot3 bump mapping):
	--------------------------------------
	How it works:
		Use a grey-level image of the size same as the texture called a height
		map. Dot-product the light applied on each point by the modified normal
		vector at this point.
	Quality: Medium
	Speed: Fast
		   Score: C?

	2] Parallax mapping (virtual displacement mapping):
	---------------------------------------------------
	How it works:
		Displace the texture coordinates at a point by a function of the view
		angle in tangent space and the value of the height map at that point.
		At steeper view-angles, the texture coordinates are displaced more,
		giving the illusion of depth due to parallax effects as the view
		changes.
	Remarks:
		Improvements are required to apply occlusion and shadowing.
	Quality: Very good
	Speed: Medium
			SCORE: B

	3] Relief mapping:
	------------------
	How it works:
		Apply a short-distance raytrace using a pixel shader. Once more, a
		height map must be used to add depth information to the textures.
	Remarks:
		Self-occlusion and self-shadowing are naturally applied.
	Quality: Very good
	Speed: Slow
			SCORE: B

	4] Displacement mapping:
	------------------------
	How it works:
		Also use a height map, but use the normals to really move (displace) the
		texture's points in space along their normals. This can only be done
		either with very fine (or automatically refined for this use) meshes,
		or non-tesselating renderers (RT).
	Remarks:
		This can be implemented using vertex shaders.
		(see http://www.ozone3d.net/tutorials/vertex_displacement_mapping.php)
	Quality:
		Best
	Speed:
		Not clear, but:
		Probably very slow if done with a RT
		Maybe fast enough if done with the GPU using shaders, although it would
		require remeshing, which could be very costly.
			SCORE:
				A with RT
				A, maybe B with vertex shaders
