
										YUNI USER INTERFACE
										FUNCTIONAL AND TECHNICAL SPECIFICATION

Started on:   2010-09-09, by Loom
Last version: 2010-09-09, by Loom

Scope of this document :
========================

This document describes the User Interface (UI), both in functional terms
(what features it should include, what the behaviour should be) and
technical terms (how the code should be written, how the classes will
interact).



I) Definitions :
================

  User Interface
  ==============
UI is a specific term that describes the presentation, interaction and
behaviour of graphic controls (windows, buttons, panels, etc) that contain
one another, launch events when they change state, and can be seen and often
modified by the user directly.


  Component
  =========
A component is a 2D entity with dimensions and properties. It can be
displayable or not. Components can also sometimes be containers for
other components. A component is a very abstract notion.


  Control
  =======
A control is a kind of component that can be displayed to screen, and
therefore seen by the user.


  UI tree
  =======
A UI tree is an arborescent structure containing components, where each
node is a container for its children. In order for this tree to be displayed,
the root node must be a Desktop, and must be inserted in a context. A UI tree
may be inserted in several contexts at the same time.


  Desktop
  =======
A desktop is a component that can contain applications. It is typically the
root of a UI tree, but does not have to be.


  Context
  =======
A context defines how a UI tree will be displayed to screen. It is a combination
of a given window system (which is OS-dependent) and a graphics back-end
(OpenGL or Cairo under all platforms, DirectX under Windows). The context holds
internal representations of the UI windows as implemented in this given context.


II) Component states :
======================
A component is always in a combination of the given states :
 - csReady = 0x0
 - csDestroying = 0x1 : The component is about to be destroyed
 - csDesigning = 0x2 : currently manipulated by the form designer
 - csClosing = 0x4 : The window is about to be closed // For a window only

Atomic::Int<32> pState;
inline bool destroying() const {return pState & csDestroying;}
inline bool designing() const {return pState & csDesigning;}
inline bool ready() const {return !(pState & (csClosing | csDestroying));}
inline bool closing() const {return pState & csClosing;}  // UI::Window


III) Class hierarchy :
======================

See ui_hierarchy.dot


IV) Directory structure :
=========================
TODO


V) UI modification :
====================
Modifications to a UI component in a UI tree are done in batch using a
way similar to the following :

{
	// Lock the data, begin update
	UI::UpdateLocker locker(listbox);

	// Clear the list
	listbox->clear();
	// Add a million items in the list
	for (unsigned int i = 0; i != 1000000; ++i)
		*listbox += "Item";
} // Update is done here when the locker falls out of scope


VI) Data synchronization :
==========================
When a component is modified, it is added to a map sorted by its depth
in the tree. When refreshing, process this structure by updating
higher-depth components first. When refreshing a component, recurse on
each of its children, and check their existence in the map. If they
are in the map, remove them to avoid updating twice.

Example:

Window_1
|
 -> Panel_1
|   |
|    -> Button_1 *
|
 -> Panel_2 *
    |
     -> CheckBox_1 *
    |
     -> Button_2

Supposing components with * are modified, the algorithm will process
them as follows :

* Step 1:
  modified : [ [ 2 , [ Panel_2 ] ] , [ 3, [ Button_1 , CheckBox_1 ] ] ]
  update Panel_2
	remove it from "modified"
    update Panel_2's children:
      update CheckBox_1
	    remove it from "modified"
	    it has no child
	  update Button_2
	    it is not in "modified"
	    it has no child

* Step 2:
  modified : [ [ 3, [ Button_1 ] ] ]
  update Button_1
    it has no child
