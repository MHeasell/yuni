
										YUNI GRAPHICS ENGINE
										FUNCTIONAL SPECIFICATION

Started on:   2009-06-12, by Loom
Last version: 2009-09-02, by Loom

Scope of this document:
=======================

Part 1) of this document includes general considerations that apply to
the entire Yuni project.
However this document in itself intends to specify all the required
features FOR THE GRAPHICS ENGINE ONLY.



I) Introduction: What is Yuni?
==============================

Preamble:
---------

The Yuni project aims at offering a complete framework for
developing high-level, complex and fast applications.
It will be shaped as a C++ library and bindings for some
scripting languages.


Target audience:
----------------

The Yuni library and tools are meant to be used by developers who
already know C++, like it and want to use it for writing any kind of
application without worrying about the low-level aspects of the
language and the trouble of mixing many kinds of libraries to do all
the usual things any application requires.

Big applications always end up requiring performance at some point,
multi-threading at some other, graphics, sound, input, command line
parsing, ... Yuni will provide all this in a portable way with a
single, easy-to-use, object-oriented API.


Objectives:
-----------
- Execution speed:
  It is crucial that the code be optimized to reach speeds
  well above average when compared to other implementations.
  This also means each computer's abilities should be used to their
  maximum (multithreading to use multiple cores in particular)

- Ease of use:
  Being easy to use is essential and therefore it should be enforced by
  offering very high-level interfaces, without losing features on the way.
  This includes having _excellent_ documentation.
  This is mainly a sales argument: "Bad API leads to few users".

- Completeness:
  If a domain is found to be in the scope of the Yuni library, all the
  features a user could expect in this domain should be provided.

- Portability:
  Yuni _must_ work seamlessly under Windows, Mac OS X and major Unices
  (particularly GNU/Linux and FreeBSD).

- Code legibility and comments:
  Yuni should strive to acquire more contributers along the way and
  keeping the code clean and commented is necessary when working in
  a team.



II) 2D User Interface
=====================

  - Event-based (onClick, onHover, keyboard shortcuts, ...)
  - Seamless integration in 3D (z-management, rotating and rescaling)
  - All the necessary controls should be available:
    * Buttons (normal, push-button, radio-button)
	* Forms
	* Combos
	* Edit (with format, strongly-typed with the data)
	* CheckBox
	* Scrollbars
	* Spreadsheet
	* Slider
    * Tabs
	* Docking (?)
	* Advanced controls for multimedia management: audio, video, image
  - Vector-based graphics when possible, but able to manage raster too



III) Graphics capabilities
==========================

  - Polygon-based meshes display
	* This is still the core of real-time 3D today. It should work properly
	and efficiently.

  - Isosurfaces display
	* Isosurfaces are an interesting, very light-weight way to represent 3D
	geometry. Whatever the renderer, there should be a way to view them (either
	directly with a RT, or through meshing with marching cubes)

  - Multiple scenes:
    * Allow real-time portals or "windows" on another scene.

  - Lights and shadows:
    * All types of lights should be managed
	* Shadows (both precomputed and realtime, hard, soft and penumbras)
	* HDR effects (bloom, color bleeding)

  - High-level camera management:
	* Allow attaching a camera somewhere on a unit and having Yuni manage it
	* Associate cameras with monitors, with devices, with parts of a split
	screen
	* Manage several cameras on a scene, or cameras on different scenes

  - 3D Effects:
	* Particle engine, explosions
	* Mesh explosions (mesh real-time volume decomposition)
	* Real 3D fog (that reacts to wind, to movements in it. Managed by physics?)
	* Bump-mapping, Parallax mapping (or other texture volume techniques)
	* Ribbon trails
	* Water simulation

  - 2D Image post-treatment (some of these could be hardware-accelerated)
	* Distortions / deformations (panoramic, waves, ...)
	* Color filters
	* Blurring, embossing, (thermal view ?)



IV) A point on Scaling
======================

Yuni is a library, so when offering any feature it should be kept in mind that
user needs may vary. Sometimes, there will be a unique best solution to a
problem, and sometimes, compromises will have to be made.
Mostly, the design choices will impact:
  - Memory usage
  - Performance
  - Graphics quality

In order to be as flexible as possible, Yuni should offer multiple answers to a
given problem, accessible through a similar interface to avoid users having to
learn multiple ways to do the same thing.
The purpose is for the user to make the choice best suited to her needs, and
avoid losing time rewriting code for a feature already in Yuni, just because
assumptions were made that do not apply to this user's situation.

Examples of features that could benefit from scaling:
  - AI (more complex AI will take more time)
  - Meshes (applying a mipmapping-equivalent to meshes, reducing triangle count
  automatically)
  - Water simulation (from simple moving textures to fluid simulation)
  - Effects
  - Shadows / Lights
  - Textures
  - Rendering engine
See the document named graphics_techniques.txt for details on what technique
should be used, why and when.



V) Resources and Formats
========================

In order for any 3D engine to become used wiely, it must allow the users to
reuse the resources they already have, be they images (or textures), meshes,
fonts or even shaders.

	1] Shaders:
	-----------

Shaders should not be a problem since few formats exist.
We cannot afford to ship without either HLSL or GLSL (respectively for DirectX
and OpenGL). It would also be nice to offer support for NVIDIA's Cg language.

	2] Images:
	----------

The most frequent image formats should be supported, although no uncompressed
raster format will be, so as not to encourage people to use 20MB bitmaps for
their textures. Of course, vector-based formats must be encouraged.

A possible list of formats would be the following (subject to changes):
 - JPEG?
 - PNG
 - SVG
 - PS / EPS

	3] Meshes:
	----------

Mesh import is crucial, noone wants to convert all of a project's meshes to a
given format. We have to completely abstract this and allow people to load
their favorite mesh format transparently.

A possible list of formats would be the following (subject to changes):
 - MilkShape3D
 - DirectX X
 - Quake3 MD3
 - 3DSMax
 - WaveFront OBJ
