#ifndef __YUNI_CORE_BIND_BIND_HXX__
# define __YUNI_CORE_BIND_BIND_HXX__


/*!
** \internal This file is automatically generated by 'bind.hxx.generator.hpp'.
** Please make any modifications you wish to this script instead of
** this file, as they will otherwise be lost at the next generation.
*/


namespace Yuni
{




	// Constructor
	template<class R>
	inline Bind<R ()>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R>
	inline Bind<R ()>::Bind(const Bind<R ()>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R>
	inline Bind<R ()>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R>
	inline void Bind<R ()>::bind(R (*pointer)())
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R ()>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R>
	template<class U>
	inline void Bind<R ()>::bind(R (*pointer)(U),
		typename Bind<R ()>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R>
	template<class C>
	void Bind<R ()>::bind(C* c, R (C::*member)())
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R()>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class C>
	void Bind<R ()>::bind(const C* c, R (C::*member)() const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)();
			pHolder = new Private::BindImpl::BoundWithMember<C, R()>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R ()>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)())
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R ()>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)() const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R ()>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(),
		typename Bind<R ()>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R ()>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)() const,
		typename Bind<R ()>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R>
	template<class C>
	void Bind<R ()>::bind(C& c, R (C::*member)())
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R()>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class C>
	void Bind<R ()>::bind(const C& c, R (C::*member)() const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)();
			pHolder = new Private::BindImpl::BoundWithMember<C, R()>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R>
	template<class U, class C>
	void Bind<R ()>::bind(C* c, R (C::*member)(U),
		typename Bind<R ()>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R>
	template<class U, class C>
	void Bind<R ()>::bind(C& c, R (C::*member)(U),
		typename Bind<R ()>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R>
	template<class U, class C>
	void Bind<R ()>::bind(const C* c, R (C::*member)(U) const,
		typename Bind<R ()>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R>
	template<class U, class C>
	void Bind<R ()>::bind(const C& c, R (C::*member)(U) const,
		typename Bind<R ()>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R>
	inline void Bind<R ()>::bind(const Bind<R ()>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R>
	inline void Bind<R ()>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R>
	inline void Bind<R ()>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R>
	inline R Bind<R ()>::invoke() const
	{
		return pHolder->invoke();
	}


	template<class R>
	inline R Bind<R ()>::operator () () const
	{
		return pHolder->invoke();
	}


	template<class R>
	inline R Bind<R ()>::emptyCallback()
	{
		return R();
	}

	template<class R>
	inline void Bind<R ()>::emptyCallbackReturnsVoid()
	{
		/* Do nothing */
	}






	template<class R>
	inline Bind<R ()>& Bind<R ()>::operator = (R (*pointer)())
	{
		bind(pointer);
		return *this;
	}


	template<class R>
	inline Bind<R ()>& Bind<R ()>::operator = (const Bind<R ()>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R>
	inline Bind<R ()>& Bind<R ()>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R>
	inline Bind<R ()>& Bind<R ()>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






	// Constructor
	template<class R, class A0>
	inline Bind<R (A0)>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0>
	inline Bind<R (A0)>::Bind(const Bind<R (A0)>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R, class A0>
	inline Bind<R (A0)>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0>
	inline void Bind<R (A0)>::bind(R (*pointer)(A0))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0)>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R, class A0>
	template<class U>
	inline void Bind<R (A0)>::bind(R (*pointer)(A0, U),
		typename Bind<R (A0)>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0>
	template<class C>
	void Bind<R (A0)>::bind(C* c, R (C::*member)(A0))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class C>
	void Bind<R (A0)>::bind(const C* c, R (C::*member)(A0) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0),
		typename Bind<R (A0)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0) const,
		typename Bind<R (A0)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R, class A0>
	template<class C>
	void Bind<R (A0)>::bind(C& c, R (C::*member)(A0))
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0)>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class C>
	void Bind<R (A0)>::bind(const C& c, R (C::*member)(A0) const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R, class A0>
	template<class U, class C>
	void Bind<R (A0)>::bind(C* c, R (C::*member)(A0, U),
		typename Bind<R (A0)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0>
	template<class U, class C>
	void Bind<R (A0)>::bind(C& c, R (C::*member)(A0, U),
		typename Bind<R (A0)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R, class A0>
	template<class U, class C>
	void Bind<R (A0)>::bind(const C* c, R (C::*member)(A0, U) const,
		typename Bind<R (A0)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0>
	template<class U, class C>
	void Bind<R (A0)>::bind(const C& c, R (C::*member)(A0, U) const,
		typename Bind<R (A0)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0>
	inline void Bind<R (A0)>::bind(const Bind<R (A0)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0>
	inline void Bind<R (A0)>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0>
	inline void Bind<R (A0)>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R, class A0>
	inline R Bind<R (A0)>::invoke(A0 a0) const
	{
		return pHolder->invoke(a0);
	}


	template<class R, class A0>
	inline R Bind<R (A0)>::operator () (A0 a0) const
	{
		return pHolder->invoke(a0);
	}


	template<class R, class A0>
	inline R Bind<R (A0)>::emptyCallback(A0)
	{
		return R();
	}

	template<class R, class A0>
	inline void Bind<R (A0)>::emptyCallbackReturnsVoid(A0)
	{
		/* Do nothing */
	}






	template<class R, class A0>
	inline Bind<R (A0)>& Bind<R (A0)>::operator = (R (*pointer)(A0))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0>
	inline Bind<R (A0)>& Bind<R (A0)>::operator = (const Bind<R (A0)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0>
	inline Bind<R (A0)>& Bind<R (A0)>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R, class A0>
	inline Bind<R (A0)>& Bind<R (A0)>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






	// Constructor
	template<class R, class A0, class A1>
	inline Bind<R (A0, A1)>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1>
	inline Bind<R (A0, A1)>::Bind(const Bind<R (A0, A1)>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R, class A0, class A1>
	inline Bind<R (A0, A1)>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1)>::bind(R (*pointer)(A0, A1))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1)>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1>
	template<class U>
	inline void Bind<R (A0, A1)>::bind(R (*pointer)(A0, A1, U),
		typename Bind<R (A0, A1)>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1>
	template<class C>
	void Bind<R (A0, A1)>::bind(C* c, R (C::*member)(A0, A1))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class C>
	void Bind<R (A0, A1)>::bind(const C* c, R (C::*member)(A0, A1) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1),
		typename Bind<R (A0, A1)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1) const,
		typename Bind<R (A0, A1)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R, class A0, class A1>
	template<class C>
	void Bind<R (A0, A1)>::bind(C& c, R (C::*member)(A0, A1))
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1)>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class C>
	void Bind<R (A0, A1)>::bind(const C& c, R (C::*member)(A0, A1) const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R, class A0, class A1>
	template<class U, class C>
	void Bind<R (A0, A1)>::bind(C* c, R (C::*member)(A0, A1, U),
		typename Bind<R (A0, A1)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1>
	template<class U, class C>
	void Bind<R (A0, A1)>::bind(C& c, R (C::*member)(A0, A1, U),
		typename Bind<R (A0, A1)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R, class A0, class A1>
	template<class U, class C>
	void Bind<R (A0, A1)>::bind(const C* c, R (C::*member)(A0, A1, U) const,
		typename Bind<R (A0, A1)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1>
	template<class U, class C>
	void Bind<R (A0, A1)>::bind(const C& c, R (C::*member)(A0, A1, U) const,
		typename Bind<R (A0, A1)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1)>::bind(const Bind<R (A0, A1)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1)>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1)>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R, class A0, class A1>
	inline R Bind<R (A0, A1)>::invoke(A0 a0, A1 a1) const
	{
		return pHolder->invoke(a0, a1);
	}


	template<class R, class A0, class A1>
	inline R Bind<R (A0, A1)>::operator () (A0 a0, A1 a1) const
	{
		return pHolder->invoke(a0, a1);
	}


	template<class R, class A0, class A1>
	inline R Bind<R (A0, A1)>::emptyCallback(A0, A1)
	{
		return R();
	}

	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1)>::emptyCallbackReturnsVoid(A0, A1)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1>
	inline Bind<R (A0, A1)>& Bind<R (A0, A1)>::operator = (R (*pointer)(A0, A1))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1>
	inline Bind<R (A0, A1)>& Bind<R (A0, A1)>::operator = (const Bind<R (A0, A1)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1>
	inline Bind<R (A0, A1)>& Bind<R (A0, A1)>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R, class A0, class A1>
	inline Bind<R (A0, A1)>& Bind<R (A0, A1)>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






	// Constructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2)>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2)>::Bind(const Bind<R (A0, A1, A2)>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2)>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2)>::bind(R (*pointer)(A0, A1, A2))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2)>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2>
	template<class U>
	inline void Bind<R (A0, A1, A2)>::bind(R (*pointer)(A0, A1, A2, U),
		typename Bind<R (A0, A1, A2)>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2>
	template<class C>
	void Bind<R (A0, A1, A2)>::bind(C* c, R (C::*member)(A0, A1, A2))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class C>
	void Bind<R (A0, A1, A2)>::bind(const C* c, R (C::*member)(A0, A1, A2) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2),
		typename Bind<R (A0, A1, A2)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2) const,
		typename Bind<R (A0, A1, A2)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2>
	template<class C>
	void Bind<R (A0, A1, A2)>::bind(C& c, R (C::*member)(A0, A1, A2))
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2)>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class C>
	void Bind<R (A0, A1, A2)>::bind(const C& c, R (C::*member)(A0, A1, A2) const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R, class A0, class A1, class A2>
	template<class U, class C>
	void Bind<R (A0, A1, A2)>::bind(C* c, R (C::*member)(A0, A1, A2, U),
		typename Bind<R (A0, A1, A2)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2>
	template<class U, class C>
	void Bind<R (A0, A1, A2)>::bind(C& c, R (C::*member)(A0, A1, A2, U),
		typename Bind<R (A0, A1, A2)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R, class A0, class A1, class A2>
	template<class U, class C>
	void Bind<R (A0, A1, A2)>::bind(const C* c, R (C::*member)(A0, A1, A2, U) const,
		typename Bind<R (A0, A1, A2)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2>
	template<class U, class C>
	void Bind<R (A0, A1, A2)>::bind(const C& c, R (C::*member)(A0, A1, A2, U) const,
		typename Bind<R (A0, A1, A2)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2)>::bind(const Bind<R (A0, A1, A2)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2)>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2)>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R, class A0, class A1, class A2>
	inline R Bind<R (A0, A1, A2)>::invoke(A0 a0, A1 a1, A2 a2) const
	{
		return pHolder->invoke(a0, a1, a2);
	}


	template<class R, class A0, class A1, class A2>
	inline R Bind<R (A0, A1, A2)>::operator () (A0 a0, A1 a1, A2 a2) const
	{
		return pHolder->invoke(a0, a1, a2);
	}


	template<class R, class A0, class A1, class A2>
	inline R Bind<R (A0, A1, A2)>::emptyCallback(A0, A1, A2)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2)>::emptyCallbackReturnsVoid(A0, A1, A2)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2)>& Bind<R (A0, A1, A2)>::operator = (R (*pointer)(A0, A1, A2))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2)>& Bind<R (A0, A1, A2)>::operator = (const Bind<R (A0, A1, A2)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2)>& Bind<R (A0, A1, A2)>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2)>& Bind<R (A0, A1, A2)>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3)>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3)>::Bind(const Bind<R (A0, A1, A2, A3)>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3)>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3)>::bind(R (*pointer)(A0, A1, A2, A3))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3)>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3)>::bind(R (*pointer)(A0, A1, A2, A3, U),
		typename Bind<R (A0, A1, A2, A3)>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	void Bind<R (A0, A1, A2, A3)>::bind(C* c, R (C::*member)(A0, A1, A2, A3))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	void Bind<R (A0, A1, A2, A3)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3),
		typename Bind<R (A0, A1, A2, A3)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3) const,
		typename Bind<R (A0, A1, A2, A3)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	void Bind<R (A0, A1, A2, A3)>::bind(C& c, R (C::*member)(A0, A1, A2, A3))
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3)>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	void Bind<R (A0, A1, A2, A3)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3) const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, U),
		typename Bind<R (A0, A1, A2, A3)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, U),
		typename Bind<R (A0, A1, A2, A3)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, U) const,
		typename Bind<R (A0, A1, A2, A3)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, U) const,
		typename Bind<R (A0, A1, A2, A3)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3)>::bind(const Bind<R (A0, A1, A2, A3)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3)>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3)>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (A0, A1, A2, A3)>::invoke(A0 a0, A1 a1, A2 a2, A3 a3) const
	{
		return pHolder->invoke(a0, a1, a2, a3);
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (A0, A1, A2, A3)>::operator () (A0 a0, A1 a1, A2 a2, A3 a3) const
	{
		return pHolder->invoke(a0, a1, a2, a3);
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (A0, A1, A2, A3)>::emptyCallback(A0, A1, A2, A3)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3)>::emptyCallbackReturnsVoid(A0, A1, A2, A3)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3)>& Bind<R (A0, A1, A2, A3)>::operator = (R (*pointer)(A0, A1, A2, A3))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3)>& Bind<R (A0, A1, A2, A3)>::operator = (const Bind<R (A0, A1, A2, A3)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3)>& Bind<R (A0, A1, A2, A3)>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3)>& Bind<R (A0, A1, A2, A3)>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4)>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4)>::Bind(const Bind<R (A0, A1, A2, A3, A4)>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4)>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4)>::bind(R (*pointer)(A0, A1, A2, A3, A4))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4)>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4)>::bind(R (*pointer)(A0, A1, A2, A3, A4, U),
		typename Bind<R (A0, A1, A2, A3, A4)>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4),
		typename Bind<R (A0, A1, A2, A3, A4)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4) const,
		typename Bind<R (A0, A1, A2, A3, A4)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4)>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4) const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, U),
		typename Bind<R (A0, A1, A2, A3, A4)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, U),
		typename Bind<R (A0, A1, A2, A3, A4)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
		typename Bind<R (A0, A1, A2, A3, A4)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
		typename Bind<R (A0, A1, A2, A3, A4)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4)>::bind(const Bind<R (A0, A1, A2, A3, A4)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4)>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4)>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (A0, A1, A2, A3, A4)>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (A0, A1, A2, A3, A4)>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (A0, A1, A2, A3, A4)>::emptyCallback(A0, A1, A2, A3, A4)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4)>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4)>& Bind<R (A0, A1, A2, A3, A4)>::operator = (R (*pointer)(A0, A1, A2, A3, A4))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4)>& Bind<R (A0, A1, A2, A3, A4)>::operator = (const Bind<R (A0, A1, A2, A3, A4)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4)>& Bind<R (A0, A1, A2, A3, A4)>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4)>& Bind<R (A0, A1, A2, A3, A4)>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5)>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5)>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5)>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5)>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5)>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5)>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5),
		typename Bind<R (A0, A1, A2, A3, A4, A5)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5)>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5) const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5)>::bind(const Bind<R (A0, A1, A2, A3, A4, A5)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5)>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5)>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (A0, A1, A2, A3, A4, A5)>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (A0, A1, A2, A3, A4, A5)>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (A0, A1, A2, A3, A4, A5)>::emptyCallback(A0, A1, A2, A3, A4, A5)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5)>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5)>& Bind<R (A0, A1, A2, A3, A4, A5)>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5)>& Bind<R (A0, A1, A2, A3, A4, A5)>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5)>& Bind<R (A0, A1, A2, A3, A4, A5)>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5)>& Bind<R (A0, A1, A2, A3, A4, A5)>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6)>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6)>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6)>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6)>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6)>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6)>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6)>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6)>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6)>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6)>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6)>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6)>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6)>::emptyCallback(A0, A1, A2, A3, A4, A5, A6)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6)>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6)>& Bind<R (A0, A1, A2, A3, A4, A5, A6)>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6)>& Bind<R (A0, A1, A2, A3, A4, A5, A6)>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6)>& Bind<R (A0, A1, A2, A3, A4, A5, A6)>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6)>& Bind<R (A0, A1, A2, A3, A4, A5, A6)>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7)>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7)>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::Bind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>& rhs)
		:pHolder(rhs)
	{}



	// Destructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::~Bind()
	{}


	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(pointer);
	}


	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>(pointer, userdata);
	}



	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::template WithUserData<U>::ParameterType userdata)
	{
		bind(SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>::WeakPointer(c), member, userdata);
	}





	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(&c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(&c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::template WithUserData<U>::ParameterType userdata)
	{
		if (&c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(const_cast<C*>(&c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::unbind()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::clear()
	{
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
	}





	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::operator = (const NullPtr*)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>::operator = (const NullPtr&)
	{
		// equivalent to unbind
		Private::BindImpl::Unbind<R, BindType>::Execute(this);
		return *this;
	}






} // namespace Yuni

#endif // __YUNI_CORE_BIND_BIND_H__
