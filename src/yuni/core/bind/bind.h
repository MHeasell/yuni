#ifndef __YUNI_CORE_BIND_BIND_H__
# define __YUNI_CORE_BIND_BIND_H__

# include "../../yuni.h"
# include "../../threads/policy.h"
# include "../static/types.h"
# include "../static/assert.h"
# include "../static/remove.h"
# include "../smartptr.h"
# include "traits.h"


/*!
** \internal This file is automatically generated by 'bind.h.generator.hpp'.
** Please make any modifications you wish to this script instead of
** this file, as they will otherwise be lost at the next generation.
*/


namespace Yuni
{


	/*!
	** \brief A delegate implementation
	**
	** How to bind a mere function :
	** \code
	** #include <iostream>
	** #include <yuni/bind.h>
	**
	** static int Foo(int value)
	** {
	** 	std::cout << "Foo: " << value << std::endl;
	** 	return 0;
	** }
	**
	** int main()
	** {
	** 	Yuni::Bind<int (int)> callback;
	** 	callback.bind(&Foo);
	** 	callback(42);
	** 	callback(61);
	** 	callback(-1)
	** 	return 0;
	** }
	** \endcode
	**
	** How to bind a member of an object :
	** \code
	** #include <iostream>
	** #include <yuni/bind.h>
	**
	** class Foo
	** {
	** public:
	**	int bar(int value)
	**	{
	** 		std::cout << "Foo::bar  : " << value << std::endl;
	** 		return 0;
	**	}
	**	int bar2(int value)
	**	{
	** 		std::cout << "Foo::bar2 : " << value << std::endl;
	** 		return 0;
	**	}
	** };
	**
	** int main()
	** {
	**	Foo foo;
	** 	Yuni::Bind<int (int)> callback;
	** 	callback.bind(foo, &Foo::bar);
	** 	callback(42);
	** 	callback(61);
	** 	callback(-1)
	** 	callback.bind(foo, &Foo::bar2);
	** 	callback(42);
	** 	callback(61);
	** 	callback(-1)
	** 	return 0;
	** }
	** \endcode
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \note This class does not take care of deleted objects. It is the responsibility
	** to the user to unbind the delegate before the linked object is delete and/or
	** to not invoke the delegate when the object does not exist.
	**
	** \note It is safe to provide a null pointer when binding the delegate
	** \note It is always safe to invoke the delegate when unbound.
	**
	** \tparam P The prototype of the targetted function/member
	*/
	template<typename P = void ()>
	class Bind
	{
		// We must use one the specialization (see below)
		YUNI_STATIC_ASSERT(false, Bind_BadFunctionOrMemberSignature);
	};





	/*!
	** \brief Bind to a function/member with 0 argument (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type

	*/
	template<class R>
	class Bind<R ()>
	{
	public:
		//! The Bind Type
		typedef Bind<R()> Type;
		//! The Bind Type
		typedef Bind<R()> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)();
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)();
		};
		enum
		{
			//! The number of arguments
			argumentCount = 0,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 0 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)());


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)());
		template<class C> void bind(C& c, R (C::*member)());

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)());
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)() const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)() const);
		template<class C> void bind(const C& c, R (C::*member)() const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)() const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke() const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () () const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)());
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback();
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid();

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R()> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R()>






	/*!
	** \brief Bind to a function/member with 1 argument (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type
	** \tparam A0 The type of the first argument
	*/
	template<class R, class A0>
	class Bind<R (A0)>
	{
	public:
		//! The Bind Type
		typedef Bind<R(A0)> Type;
		//! The Bind Type
		typedef Bind<R(A0)> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)(A0);
		};
		enum
		{
			//! The number of arguments
			argumentCount = 1,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 1 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0));
		template<class C> void bind(C& c, R (C::*member)(A0));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0) const);
		template<class C> void bind(const C& c, R (C::*member)(A0) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(A0, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(A0, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke(A0 a0) const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () (A0 a0) const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0));
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R(A0)>






	/*!
	** \brief Bind to a function/member with 2 arguments (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type
	** \tparam A0 The type of the first argument
	** \tparam A1 The type of the second argument
	*/
	template<class R, class A0, class A1>
	class Bind<R (A0, A1)>
	{
	public:
		//! The Bind Type
		typedef Bind<R(A0, A1)> Type;
		//! The Bind Type
		typedef Bind<R(A0, A1)> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)(A0, A1);
		};
		enum
		{
			//! The number of arguments
			argumentCount = 2,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 2 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1));
		template<class C> void bind(C& c, R (C::*member)(A0, A1));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1) const);
		template<class C> void bind(const C& c, R (C::*member)(A0, A1) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(A0, A1, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(A0, A1, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke(A0 a0, A1 a1) const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () (A0 a0, A1 a1) const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1));
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1)>






	/*!
	** \brief Bind to a function/member with 3 arguments (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type
	** \tparam A0 The type of the first argument
	** \tparam A1 The type of the second argument
	** \tparam A2 The type of the third argument
	*/
	template<class R, class A0, class A1, class A2>
	class Bind<R (A0, A1, A2)>
	{
	public:
		//! The Bind Type
		typedef Bind<R(A0, A1, A2)> Type;
		//! The Bind Type
		typedef Bind<R(A0, A1, A2)> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)(A0, A1, A2);
		};
		enum
		{
			//! The number of arguments
			argumentCount = 3,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 3 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2));
		template<class C> void bind(C& c, R (C::*member)(A0, A1, A2));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2) const);
		template<class C> void bind(const C& c, R (C::*member)(A0, A1, A2) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(A0, A1, A2, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(A0, A1, A2, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke(A0 a0, A1 a1, A2 a2) const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () (A0 a0, A1 a1, A2 a2) const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2));
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2)>






	/*!
	** \brief Bind to a function/member with 4 arguments (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type
	** \tparam A0 The type of the first argument
	** \tparam A1 The type of the second argument
	** \tparam A2 The type of the third argument
	** \tparam A3 The type of the 4th argument
	*/
	template<class R, class A0, class A1, class A2, class A3>
	class Bind<R (A0, A1, A2, A3)>
	{
	public:
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3)> Type;
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3)> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)(A0, A1, A2, A3);
		};
		enum
		{
			//! The number of arguments
			argumentCount = 4,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 4 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3));
		template<class C> void bind(C& c, R (C::*member)(A0, A1, A2, A3));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3) const);
		template<class C> void bind(const C& c, R (C::*member)(A0, A1, A2, A3) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(A0, A1, A2, A3, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(A0, A1, A2, A3, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3) const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3) const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3));
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3)>






	/*!
	** \brief Bind to a function/member with 5 arguments (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type
	** \tparam A0 The type of the first argument
	** \tparam A1 The type of the second argument
	** \tparam A2 The type of the third argument
	** \tparam A3 The type of the 4th argument
	** \tparam A4 The type of the 5th argument
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4>
	class Bind<R (A0, A1, A2, A3, A4)>
	{
	public:
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4)> Type;
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4)> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)(A0, A1, A2, A3, A4);
		};
		enum
		{
			//! The number of arguments
			argumentCount = 5,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 5 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4));
		template<class C> void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4) const);
		template<class C> void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4));
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4)>






	/*!
	** \brief Bind to a function/member with 6 arguments (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type
	** \tparam A0 The type of the first argument
	** \tparam A1 The type of the second argument
	** \tparam A2 The type of the third argument
	** \tparam A3 The type of the 4th argument
	** \tparam A4 The type of the 5th argument
	** \tparam A5 The type of the 6th argument
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	class Bind<R (A0, A1, A2, A3, A4, A5)>
	{
	public:
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5)> Type;
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5)> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)(A0, A1, A2, A3, A4, A5);
		};
		enum
		{
			//! The number of arguments
			argumentCount = 6,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 6 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5));
		template<class C> void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5) const);
		template<class C> void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5));
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5)>






	/*!
	** \brief Bind to a function/member with 7 arguments (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type
	** \tparam A0 The type of the first argument
	** \tparam A1 The type of the second argument
	** \tparam A2 The type of the third argument
	** \tparam A3 The type of the 4th argument
	** \tparam A4 The type of the 5th argument
	** \tparam A5 The type of the 6th argument
	** \tparam A6 The type of the 7th argument
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6)>
	{
	public:
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6)> Type;
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6)> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)(A0, A1, A2, A3, A4, A5, A6);
		};
		enum
		{
			//! The number of arguments
			argumentCount = 7,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 7 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));
		template<class C> void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const);
		template<class C> void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6));
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6)>






	/*!
	** \brief Bind to a function/member with 8 arguments (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type
	** \tparam A0 The type of the first argument
	** \tparam A1 The type of the second argument
	** \tparam A2 The type of the third argument
	** \tparam A3 The type of the 4th argument
	** \tparam A4 The type of the 5th argument
	** \tparam A5 The type of the 6th argument
	** \tparam A6 The type of the 7th argument
	** \tparam A7 The type of the 8th argument
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7)>
	{
	public:
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7)> Type;
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7)> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)(A0, A1, A2, A3, A4, A5, A6, A7);
		};
		enum
		{
			//! The number of arguments
			argumentCount = 8,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 8 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));
		template<class C> void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const);
		template<class C> void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7)>






	/*!
	** \brief Bind to a function/member with 9 arguments (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type
	** \tparam A0 The type of the first argument
	** \tparam A1 The type of the second argument
	** \tparam A2 The type of the third argument
	** \tparam A3 The type of the 4th argument
	** \tparam A4 The type of the 5th argument
	** \tparam A5 The type of the 6th argument
	** \tparam A6 The type of the 7th argument
	** \tparam A7 The type of the 8th argument
	** \tparam A8 The type of the 9th argument
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>
	{
	public:
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)> Type;
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
		};
		enum
		{
			//! The number of arguments
			argumentCount = 9,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 9 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		template<class C> void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const);
		template<class C> void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>






	/*!
	** \brief Bind to a function/member with 10 arguments (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type
	** \tparam A0 The type of the first argument
	** \tparam A1 The type of the second argument
	** \tparam A2 The type of the third argument
	** \tparam A3 The type of the 4th argument
	** \tparam A4 The type of the 5th argument
	** \tparam A5 The type of the 6th argument
	** \tparam A6 The type of the 7th argument
	** \tparam A7 The type of the 8th argument
	** \tparam A8 The type of the 9th argument
	** \tparam A9 The type of the 10th argument
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>
	{
	public:
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)> Type;
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
		};
		enum
		{
			//! The number of arguments
			argumentCount = 10,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 10 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		template<class C> void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const);
		template<class C> void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>






	/*!
	** \brief Bind to a function/member with 11 arguments (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type
	** \tparam A0 The type of the first argument
	** \tparam A1 The type of the second argument
	** \tparam A2 The type of the third argument
	** \tparam A3 The type of the 4th argument
	** \tparam A4 The type of the 5th argument
	** \tparam A5 The type of the 6th argument
	** \tparam A6 The type of the 7th argument
	** \tparam A7 The type of the 8th argument
	** \tparam A8 The type of the 9th argument
	** \tparam A9 The type of the 10th argument
	** \tparam A10 The type of the 11th argument
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>
	{
	public:
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)> Type;
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
		};
		enum
		{
			//! The number of arguments
			argumentCount = 11,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 11 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		template<class C> void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const);
		template<class C> void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>






	/*!
	** \brief Bind to a function/member with 12 arguments (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type
	** \tparam A0 The type of the first argument
	** \tparam A1 The type of the second argument
	** \tparam A2 The type of the third argument
	** \tparam A3 The type of the 4th argument
	** \tparam A4 The type of the 5th argument
	** \tparam A5 The type of the 6th argument
	** \tparam A6 The type of the 7th argument
	** \tparam A7 The type of the 8th argument
	** \tparam A8 The type of the 9th argument
	** \tparam A9 The type of the 10th argument
	** \tparam A10 The type of the 11th argument
	** \tparam A11 The type of the 12th argument
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>
	{
	public:
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)> Type;
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
		};
		enum
		{
			//! The number of arguments
			argumentCount = 12,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 12 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		template<class C> void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const);
		template<class C> void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>






	/*!
	** \brief Bind to a function/member with 13 arguments (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type
	** \tparam A0 The type of the first argument
	** \tparam A1 The type of the second argument
	** \tparam A2 The type of the third argument
	** \tparam A3 The type of the 4th argument
	** \tparam A4 The type of the 5th argument
	** \tparam A5 The type of the 6th argument
	** \tparam A6 The type of the 7th argument
	** \tparam A7 The type of the 8th argument
	** \tparam A8 The type of the 9th argument
	** \tparam A9 The type of the 10th argument
	** \tparam A10 The type of the 11th argument
	** \tparam A11 The type of the 12th argument
	** \tparam A12 The type of the 13th argument
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>
	{
	public:
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)> Type;
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
		};
		enum
		{
			//! The number of arguments
			argumentCount = 13,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 13 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		template<class C> void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const);
		template<class C> void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>






	/*!
	** \brief Bind to a function/member with 14 arguments (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type
	** \tparam A0 The type of the first argument
	** \tparam A1 The type of the second argument
	** \tparam A2 The type of the third argument
	** \tparam A3 The type of the 4th argument
	** \tparam A4 The type of the 5th argument
	** \tparam A5 The type of the 6th argument
	** \tparam A6 The type of the 7th argument
	** \tparam A7 The type of the 8th argument
	** \tparam A8 The type of the 9th argument
	** \tparam A9 The type of the 10th argument
	** \tparam A10 The type of the 11th argument
	** \tparam A11 The type of the 12th argument
	** \tparam A12 The type of the 13th argument
	** \tparam A13 The type of the 14th argument
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>
	{
	public:
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)> Type;
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
		};
		enum
		{
			//! The number of arguments
			argumentCount = 14,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 14 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		template<class C> void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const);
		template<class C> void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>






	/*!
	** \brief Bind to a function/member with 15 arguments (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type
	** \tparam A0 The type of the first argument
	** \tparam A1 The type of the second argument
	** \tparam A2 The type of the third argument
	** \tparam A3 The type of the 4th argument
	** \tparam A4 The type of the 5th argument
	** \tparam A5 The type of the 6th argument
	** \tparam A6 The type of the 7th argument
	** \tparam A7 The type of the 8th argument
	** \tparam A8 The type of the 9th argument
	** \tparam A9 The type of the 10th argument
	** \tparam A10 The type of the 11th argument
	** \tparam A11 The type of the 12th argument
	** \tparam A12 The type of the 13th argument
	** \tparam A13 The type of the 14th argument
	** \tparam A14 The type of the 15th argument
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>
	{
	public:
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)> Type;
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
		};
		enum
		{
			//! The number of arguments
			argumentCount = 15,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 15 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		template<class C> void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const);
		template<class C> void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>






	/*!
	** \brief Bind to a function/member with 16 arguments (Specialization)
	**
	** This class is thread-safe, this is guarantee by the use of smartptr.
	**
	** \tparam R The return Type
	** \tparam A0 The type of the first argument
	** \tparam A1 The type of the second argument
	** \tparam A2 The type of the third argument
	** \tparam A3 The type of the 4th argument
	** \tparam A4 The type of the 5th argument
	** \tparam A5 The type of the 6th argument
	** \tparam A6 The type of the 7th argument
	** \tparam A7 The type of the 8th argument
	** \tparam A8 The type of the 9th argument
	** \tparam A9 The type of the 10th argument
	** \tparam A10 The type of the 11th argument
	** \tparam A11 The type of the 12th argument
	** \tparam A12 The type of the 13th argument
	** \tparam A13 The type of the 14th argument
	** \tparam A14 The type of the 15th argument
	** \tparam A15 The type of the 16th argument
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	class Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>
	{
	public:
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)> Type;
		//! The Bind Type
		typedef Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)> BindType;
		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember
		{
			//! Type for a pointer-to-member
			typedef R (C::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
		};
		enum
		{
			//! The number of arguments
			argumentCount = 16,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		//! The type of the return value
		typedef R ReturnType;
		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		*/
		template<class U>
		struct WithUserData
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 16 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		//! \name Constructor & Destructor
		//@{
		/*!
		** \brief Default Constructor
		*/
		Bind();
		/*!
		** \brief Copy constructor
		*/
		Bind(const Bind& rhs);
		/*!
		** \brief Destructor
		*/
		~Bind();
		//@}

		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));


		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		template<class C> void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const);
		template<class C> void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const);


		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const, typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);
		//@} // Bind

		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const;

		/*!
		** \brief Invoke the delegate
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const;
		//@}

		//! \name Operators
		//@{
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr*);
		//! Assignment with a nullptr (equivalent to unbind)
		Bind& operator = (const NullPtr&);
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		// A friend !
		template<class R1, class B1> friend class Private::BindImpl::Unbind;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>











} // namespace Yuni

# include "bind.hxx"

#endif // __YUNI_CORE_BIND_BIND_H__
