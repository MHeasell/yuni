
										YUNI SOUND ENGINE
										FUNCTIONAL SPECIFICATION

Started on:   2009-11-02, by Loom
Last version: 2009-11-02, by Loom

Scope of this document:
=======================

This document intends to specify all the required features FOR THE SOUND
ENGINE ONLY. It will be biased towards what can be done with the current
mainstream libraries, particularly OpenAL, although this document implies
in no way that OpenAL will be or should be chosen as a library for Yuni.

I) General observations:
========================
3D sound requires all objects that generate sound or interact with sound to
be placed spatially. This is of course because distance influences sound.
However, this is not enough: object velocities are required too, for the
Doppler effect to be taken into account. OpenAL offers ways to control the
Doppler shift by modifying the speed of sound and Doppler factor, but this
is not a required feature for Yuni to implement.

It is required that Yuni use hardware acceleration for sound as much as
possible for obvious performance reasons.


I) Entities:
============

- Listener
  - Position
  - Speed vector (orientation + velocity)
- Source
  - Position
  - Speed vector (direction + velocity)
  - Unique identifier
- Sound
  - Various storage formats (no compression, compression, lossless compression)
    WAV, MP3, OGG, FLAC, ...
  - File-by-file sounds, or sound banks
  - Specific settings to modify (volume, speed, playing backwards, ...)
  - Continuous streaming
  - Unique identifier

II) Features:
=============

In this section, no distinction is done between the data of a sound, and the
way it is represented in a program. OpenAL distinguishises between sounds and
the buffers in which they are loaded, but this is too low-level for the scope
of this document.

Listeners:
- Always one listener exists
- Only one active listener at a time (?)
- Create another listener
- Destroy a listener that is not active
- Know how to move a listener, or how to update when a listener moves

Sources:
- Create a source
- Destroy a source
- Know how to move a source, or how to update when a source moves

Sounds:
- Load a sound
- Unload a sound
- Play a sound at a given source
- Pause a sound
- Stop a sound

It should be possible to preload a sound (synchronously or asynchronously) at
a given time, so as to avoid any latency when starting the playback.
It should be possible to specify whether a sound will loop or not, and how
the resources should be freed:
  - as soon as possible
  - only when the user asks for it
  - as late as possible (destruction of the source / buffer, program exit, ...)

Customization:
- Change a sound's volume
- Change a source's volume (all sounds playing on a source)
- Change global 3D volume (listener volume)
- Change music volume
- Apply effects on a sound
- Apply effects on a source (all sounds playing on a source)
- Apply effects on a listener (all sounds it hears)
- Change a sound's playing speed?

III) Use cases:
===============

  1. Play a music:
  ----------------
The user wants to play a music to add ambiance to a game for example.

 * It has no 3D position.
 * It may be either stereo or mono.
 * It must play at global music volume with no attenuation.
 * It may be played from a file, a CD, or from a streaming source.
 * Playing should be continuous with no audible lag.

  2. Play a one-time sound effect:
  --------------------------------
The user wants to play a sound effect that will occur only once, for example
the voice announcing the beginning of a race.

 * It may be either positioned in 3D or not.
 * It may be either stereo or mono, but must be mono if in 3D.
 * It will have its own gain, combined with the main volume for sound effects.
 * It should only be played from a file.
 * It may be automatically unloaded afterwards.

  3. Play a recurring sound effect:
  ---------------------------------
The user wants to play a sound effect that will occur many times, for example
a sound of gunshot during an FPS game.

 * It may be either positioned in 3D or not.
 * It may be either stereo or mono, but must be mono if in 3D.
 * It will have its own gain, combined with the main volume for sound effects.
 * It should only be played from a file.
 * It must remain loaded as long as the user does not tell otherwise.

  4. Play a looping sound:
  ------------------------
The user wants to play a sound that will loop on itself, for example the sound
of a car engine that keeps running for some time, or the sound of water falling.

 * It will probably be positioned in 3D, but it should be allowed not to.
 * It may be either stereo or mono, but must be mono if in 3D.
 * It will have its own gain, combined with the main volume for sound effects.
 * It should only be played from a file.
 * It must remain loaded as long as the user does not tell otherwise.

IV) Possible API interfaces:
============================
This part is not normative, it only attempts to naively offer possibilities as
to what the Yuni calls may look like.

int main()
{
	// How this will be prototyped will depend on the VFS implementation
	Yuni::Audio::Music<DisposeTraits::Immediate> myMusic("tralala.mp3");

	// Each sound or music will have a unique ID
	UID myMusicID = myMusic.UID();

	// Properties might be used to manipulate sound settings
	myMusic["looping"] = false;

	// A music has no sound gain for itself, it uses the main music volume
	Yuni::Audio::Music::musicVolume(0.8f);

	// Load the beginning of the music to be ready to play
	myMusic.prepare();

	// Start playback
	myMusic.play();
}
