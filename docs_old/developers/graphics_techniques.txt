
							Computer Graphics Techniques


I) Purpose of the document:
===========================

This document is a technical state of the art on computer graphics. The point
is to list known techniques, explain quickly how they work, and recognize each
of them's qualities and drawbacks, with a particular interest on performance,
memory usage and visual quality.

The second step in this approach is to identify, for each graphics feature,
which technique should be used depending on a given context. Each technique can
then be categorized as adapted to situations where:
 A) Best quality is required, whatever the cost (not real-time).
 B) Good quality is required in real-time.
 C) Resources are very limited.
 D) Not interesting in any situation.

The "Quality" and "Memory usage" criteria can take the following values:
  - Very low
  - Low
  - Average
  - High
  - Very high

The "Speed" criterium can take the following values:
  - Very slow
  - Slow
  - Average
  - Fast
  - Very fast



II) Techniques by feature:
==========================

  Shadows:
  ========
	This part will address techniques devoted entirely to shadow generation.
	The main topics of shadow generation are whether the technique is precise or
	loosely approximated, and whether it can manage hard, soft and penumbra
	shadows.


	0] No shadows:
	--------------
	How it works:
		Do nothing.
	Quality:
		Very low
	Memory usage:
		Very low
			SCORE: D

	1] Shadow mapping:
	------------------
	How it works:
		Make a first render in Z-Buffer using the light as a camera.
		Objects failing the Z-test are in shadow
	Remarks:
		Not always very precise, creates hard shadows only, requires multiple
		passes, can induce shadow continuity glitches.
	Quality:
		Average
	Speed:
		Fast
	Memory usage:
		Average
			SCORE: C

	2] Shadow volumes with stencil buffering:
	-----------------------------------------
	How it works:
		Construct all the volumes of the scene that are in shadow.
		Use stencil buffer and Z-buffer to count the number of light/shadow
		faces crossed by the ray for each pixel.
	Remarks:
		There are adjustments to be made when the eye is in shadow.
		A technique exists to avoid the problem altogether, but it is patented.
	Quality:
		High
	Speed:
		Slow
	Memory usage:
		High
			SCORE: B


  Lighting:
  =========
	This part studies the techniques for solving all the problems linked with
	lighting: diffuse reflection, specular reflection, caustics.
	The techniques include per-polygon, per-vertex or even per-pixel
	calculations.


	1] Flat shading:
	----------------
	How it works:
		Simply use polygon normals, calculate a color (using the Phong
		reflection model: ambient, diffuse, specular) depending only on the
		orientation of the polygon face towards the light(s).
	Remarks:
		This is a very basic method of illumination, as seen in very old games.
		Corresponds to glShadeModel(FL_FLAT).
	Quality:
		Very low
	Speed:
		Very fast
			SCORE: C

	2] Gouraud shading:
	-------------------
	How it works:
		Use vertex normals to calculate color at each vertex (using the Phong
		reflection model), then interpolate between these vertices.
	Remarks:
		Does not handle specular highlights correctly (or in some cases at all).
	Quality:
		Low
	Speed:
		Fast
			SCORE: C

	3] Phong shading:
	-----------------
	How it works:
		Improving on Gouraud shading, Phong shading interpolates surface normals
		normalized at each pixel, where the color is then computed (using the
		Phong reflection model).
	Remarks:
		This is frequently implemented using pixel shaders. ALthough better than
		Gouraud shading, it remains a local illumination method, and as such is
		far from realistic.
	Quality:
		Average
	Speed:
		Fast if done with pixel shaders, Slow otherwise
			SCORE: B+C

	4] Ambient occlusion:
	---------------------
	How it works:
		This is an addition to local illumination techniques that takes into
		account attenuation of light due to occlusion. It could also be seen as
		approximating the way light reflects off non-reflective surfaces.
		It is computed by casting rays in every direction from the surface.
		Rays which hit polygons from the scene do not contribute; rays who
		hit the sky or the background brighten the surface. One optimization
		would be to use the Monte Carlo method for raycasting.
	Remarks:
		The ambient occlusion shading model has the nice property of offering
		a better perception of the 3D shape of the displayed objects.
		Another approach (more suited to hardware acceleration) is to render
		the view from p by rasterizing black geometry against a white
		background and taking the (cosine-weighted) average of rasterized
		fragments.
	Quality:
		High
	Speed:
		Unclear, but probably acceptable if GPU-accelerated
			SCORE: B

	5] Radiosity:
	-------------
	How it works:
		This is a global illumination technique, inspired by heat transfer. It
		is an application of the finite element method to solving the rendering
		equation for scenes with purely diffuse surfaces.
		It accounts for diffuse indirect lighting as well as direct
		illumination.
		Divide the surfaces into smaller patches.
		Compute a view factor for each pair of patches, which will be lower if
		patches are far away or at oblique angles (0 if view is blocked).
		Structure the patches using these view factors (e.g. by using a BSP).
		The patches can then be evaluated either by solving a linearized form of
		the rendering equation with the view factors as coefficients, or
		iteratively (each iteration being one bounce of the light on the
		patches).
	Remarks:
		Radiosity will not account for specular or glossy reflection.
		It has trouble resolving sudden changes in visibility (e.g. hard
		shadows).
		It is possible to precompute radiosity lighting for static scenes and
		lights (or fake it: "False radiosity").
	Quality:
		High
	Speed:
		Unclear, but probably acceptable if GPU-accelerated
			SCORE: B

	6] Photon mapping:
	------------------
		TODO


  Rendering:
  ==========

	1] Software rendering on triangle meshes:
    -----------------------------------------
	Quality:
		Low to High
	Speed:
		Slow
			SCORE: D

	2] Hardware rendering on triangle meshes:
	-----------------------------------------
	Quality:
		High to Very high
	Speed:
		Fast
			SCORE: B + C

	3] Ray-tracing on vector-based geometry:
	----------------------------------------
	Quality:
		Very high
	Speed:
		Very slow (not real-time)
			SCORE: A


  Bump-mapping:
  =============
	Bump-mapping is the concept of applying normal-based modifications to a
	2D texture in order to simulate 3D details (wrinkles, impacts, ...).


	0] No bump-mapping at all:
	--------------------------
	How it works:
		Do nothing.
	Quality:
		Very low
	Speed:
		Very fast
			SCORE: C

	1] Emboss bump mapping:
	-----------------------
	How it works:
		This process duplicates the first texture image, shifts it over to the
		desired amount of bump, darkens the texture underneath, cuts out the
		appropriate shape from the texture on top, and blends the two textures
		into one.
	Remarks:
		Usually run on CPU. Only affects diffuse lighting. Illusion may be
		broken depending on the angle of light.
	Quality:
		Average
	Speed:
		Fast
	SCORE: D

	2] Normal mapping (dot3 bump mapping):
	--------------------------------------
	How it works:
		Use a grey-level image of the same size as the texture called a height
		map. Dot-product the light applied on each point by the modified normal
		vector at this point.
	Quality:
		Average
	Speed:
		Fast
			SCORE: C?

	3] Parallax mapping (virtual displacement mapping):
	---------------------------------------------------
	How it works:
		Displace the texture coordinates at a point by a function of the view
		angle in tangent space and the value of the height map at that point.
		At steeper view-angles, the texture coordinates are displaced more,
		giving the illusion of depth due to parallax effects as the view
		changes.
	Remarks:
		Improvements are required to apply occlusion and shadowing.
	Quality:
		Very high
	Speed:
		Medium
			SCORE: B

	4] Relief mapping:
	------------------
	How it works:
		Apply a short-distance raytrace using a pixel shader. Once more, a
		height map must be used to add depth information to the textures.
	Remarks:
		Self-occlusion and self-shadowing are naturally applied.
	Quality:
		Very high
	Speed:
		Slow
			SCORE: B

	5] Displacement mapping:
	------------------------
	How it works:
		Also use a height map, but use the normals to really move (displace) the
		texture's points in space along their normals. This can only be done
		either with very fine (or automatically refined for this use) meshes,
		or non-tesselating renderers (RT).
	Remarks:
		This can be implemented using vertex shaders.
		(see http://www.ozone3d.net/tutorials/vertex_displacement_mapping.php)
	Quality:
		Very high
	Speed:
		Not clear, but:
		Probably very slow if done with a RT
		Maybe fast enough if done with the GPU using shaders, although it would
		require remeshing, which could be very costly.
			SCORE:
				A with RT
				A, maybe B with vertex shaders
