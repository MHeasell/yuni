

The Nany Language
=================


Introduction
------------

Nany (/na.ni/) is meant to be a modern language, created for fast,
safe, efficient programming in multi-threaded distributed
environments. It is a very high-level language which offers various
features to help you write programs :
* Object orientation
* Type inference
* Garbage collection
* Comprehension lists
* Parallel and event-driven programming
* Closures
* Live Distributed Objects
* Workflows
* Duck typing through static constraints
* Contracts through dynamic constraints
* Generics
* Predicates
* Support for Doxygen comments
This list is non-exhaustive.

### Hello, World !

It is traditional to offer a "Hello, World !" program to demonstrate
the overall syntax flavour of the language. Here it is in Nany :

    program HelloWorld;
    
    function main
    {
        system.io.println("Hello, World !");
    }

As you can see, it is very concise, and does not require a class to
encapsulate the main function (as is the case in Java and C#). Also,
you can see that the function's return type is inferred.


Basics
------

### Comments

Nany allows for several types of comments and several syntaxes for
each type.

#### In-line comments

In-line comments can be written either with `#` or with `//` :

    doSomething(a, b); // This will call the doSomething function on a and b
    doNothing;         # This does not do much actually

#### Multi-line comments

Multi-line comments can be written either with `#* *#` or with `/* */` :

    doSomething; /* This is a multi-line
    comment that can spread
    quite far */ doSomethingElse; #* This is another
    comment *#

#### Doxygen comments

It is possible to write Doxygen-style comments for automatic code
documentation :

    #*!
    ** \brief Get the length of an object
    *#
    function length(s): int { s.length }

    /*!
    ** \brief Get the number of items in a container
    */
    function count(c): int { c.count }

### Variables

The syntax for variable declaration is as follows :

    <identifier> : <type> := <expression> ;

Variable declaration in Nany requires initialization. If there is no
initialization, the default value for the specified type will be used.
Since types are inferred, it is not mandatory to specify the type.
However, it is not allowed to write neither the type nor the
initialization, since the identifier would then be interpreted as a
return value instead of a declaration.

Some examples of variable declaration

    program VariableDeclarations;
    
    class A { create() {} }
    
    function main
    {
        i := 0;        // integer
        j := 42u;      // unsigned integer
        s : string;    // string, will be initialized to ""
        a: A := new A; // class A
        aa: A;         // class A, will be initialized to nil
        b              // ERROR : unknown identifier used as return value
    }

### Functions

In Nany, it is not possible to declare a function without defining it
(there is no forward declaration). The full syntax for defining a
function is as follows :

    <qualifier> function <identifier>(<identifier>: <type>, <identifier>: <type>, ...): <type>
    {
        <expression>
    }

Since types are inferred, all types in the declaration are optional.
Also, in Nany, parentheses are optional on function declarations and
function calls if there is no argument. For example :

    program Test;
    
    function doSomething
    {
        // snip
    }
    
    function main
    {
        doSomething;
        0
    }

Following these principles, these two functions are exactly
equivalent :

    function main { 0 }

    function main() : int { 0 }


### Classes

Since Nany offers object orientation, there are classes. This is the
syntax for class definitions :

    class <identifier>
    {
    }

Note there is no required `;` (semi-comma) after the `}` (right curly
brace).

#### Attributes

The syntax for class attributes is similar to simple variable
definitions :

    class <identifier>
    {
        <qualifier> <identifier> : <type> := <expression> ;
    }

Once again, you need to provide either typing or an initialization
value.

#### Methods

The syntax for class methods uses a `method` keyword similarly to the
way functions are defined :

    class <identifier>
    {
        <qualifier> method <identifier> (<identifier> : <type>, <identifier> : <type>, ...) : <type>
        {
            # Method body here
        }
    }

Just as functions can not be forward-declared, methods must be
defined directly in the class, as it is done in Java or C#. It is up
to the tools to extract a clean public interface for external use.

#### Visibility

There are four visibilities available inside classes :
* `published` : `public` and accessible in the tools' interface designer
* `public` : Accessible by any code that uses the containing module
* `protected` : Accessible by the class itself and its inheritors
* `private` : Only accessible by the class itself

__Default visibility for classes, methods and attributes is `public`__

Syntax for visibility in classes is as follows :

    published class A
    {
    private
        myPrivateInt := 0;
        myPrivateString := "";
    public
        method myPublicMethod { return myPrivateString.length + myPrivateInt }
    }

#### Operator overloading

It is possible to overload most operators using the `operator` keyword.

    class MyInteger
    {
    private
        value: int;

    public
        operator + (x) { value + x }

        operator * (x) { value * x }
    }

#### Generics

Nany offers C#-like generics for classes. They are useful for generic
static typing of attributes. They do not offer the same expressivity
as C++ templates, because type inference, constraints and
specializations already cater to all these needs (see related
chapters).

The syntax is a lot like C# generics too :

    class Pair<K, V>
    {
    private
        key: K;
        value: V;

    public
        operator [k] { value }
    }

To apply explicit constraints on generic types, see the specific
chapter on type constraints.


#### Sample

This sample class illustrates what a class would look like in Nany :

    /*!
    ** \brief Naive vector implementation
    */
    class Vector<T>
    {
    private
        const MaxSize := 65536u;
        pData := new T[MaxSize];
		pSize := 0u;

    public
        method get(i)
        {
            pData[i]
        }

        method set(i, value)
        {
            pData[pSize++] := value
        }

		operator [i](value)
        {
            set(i, value)
        }

		operator [i]
        {
            get(i)
        }

        method add(value)
        {
            pData[i]
        }

		method size
        {
            pSize
        }
    }


Typing
------

### Built-in types

Nany offers several built-in types :
* uint
* uint8
* uint16
* uint32
* uint64
* uint128
* int
* int8
* int16
* int32
* int64
* int128
* float
* double
* double128
* bool
* any

Any represents any one type. Depending on circumstances, the
corresponding type may be known at compile time or not.


### Type manipulation

#### typeof

    typeof(Expression)

The `typeof` function evaluates the type of an expression and
returns it.

#### is

    Expression is Type

The `is` binary operator evaluates whether the left-hand operand
has or inherits a given type. It will return a boolean with the
answer.

#### as

    Expression as Type

The `as` binary operator tries to cast the left-hand operand into
the right-hand operand (which must be a type). If the cast fails,
it returns `nil`;

#### Combining it all

    function foo(s, t)
    {
        s := getValue;
        t := getOtherValue;
        if s is typeof(t) then
	        return s as typeof(t);
    }


### Type inference and overloading

Nany uses type inference, which means explicit typing of variables,
function parameters, and function return types is optional. Type
inference forbids overload with the same number of parameters. For
example :

    public function foo(i) { system.io.println("" << i); }
    
    public function foo(s: string) { system.io.println(s); }

would generate a compile error, because a call to `foo` with a
string argument would be ambiguous.

If the number of arguments is different, the call is not ambiguous
and the program is valid :

    public function foo(i) { system.io.println("" << i); i }
    
    public function foo(i, j) { system.io.println("" << i); j }

Considering the following :

    public function foo(i: int) { system.io.println("" << i); }
    
    public function foo(s: string) { system.io.println(s); }

it would seem that the call is not ambiguous, since both types were
explicitly given. However, Nany does not allow this, and offers a
different way to express the same idea using specializations (see
function specializations).


### Type constraints

It is possible to provide explicit and implicit constraints on types,
which will be evaluated statically when possible, dynamically when
not.

Duck typing example (implicit constraint on type) :

    public function foo(a): int
    {
        a.bar(42)
    }

Implicitly, this code requires that variable `a` be of a type that
defines a method with the following prototype :

    public method bar(x: int): int

Conversely, it is possible to specify the constraint explicitly :

    public function foo(a): int
    in
        typeof(a).hasMethod("bar", int, int);
    {
        a.bar(42)
    }

The two samples are equivalent.

They will be evaluated statically (at compile time) on all calls
where the type is known at compilation. If the constraint is
violated, the compiler will produce an error.

If the type is not known at compile time, the constraint will be
evaluated dynamically (during execution). If the constraint is
violated, the program will throw an exception (this is the default,
but the behaviour can be modified).

__Compiler implementation tip: we advise to implement duck typing
using hidden constraints for coherency. For example, if the developer
wrote the first sample, the compiler would automatically generate the
constraint from the second sample.__


Expressions
-----------

In Nany, many things are expressions. There is no actual statement
that is not an expression. Possible expressions in Nany are as
follows.

### Literals

* <integer literal>
* <real literal>
* <string literal>
* <boolean literal>
* <nil>

### Structured types

* <expression> . <identifier>
* <identifier> [ <expression> ]
* (<expression>, <expression>, ...)
* [<expression>..<expression>]
* [<expression> => <expression>, <expression> => <expression>, ...]

### Function calls

* <identifier>
* <expression> ( <expression> , <expression>, ...)

### Operators

* - <expression>
* -- <expression>
* ++ <expression>
* <expression> --
* <expression> ++
* <expression> + <expression>
* <expression> - <expression>
* <expression> * <expression>
* <expression> / <expression>
* <expression> % <expression>
* <expression> < <expression>
* <expression> > <expression>
* <expression> <= <expression>
* <expression> >= <expression>
* ! <expression>
* not <expression>
* <expression> = <expression>
* <expression> != <expression>
* <expression> or <expression>
* <expression> and <expression>
* <expression> xor <expression>
* <expression> | <expression>
* <expression> ~ <expression>
* <identifier> __in__ <expression>
* __in__ <expression>
* <expression> __on__ <expression>
* <expression> __is__ <expression>
* <expression> __as__ <expression>
* & <expression>

### Assignment

Assignments are void expressions.

* <expression> := <expression>

### Allocation

* new <expression>
* new <expression> ( <expression> , <expression> , ... )
* new <expression> [ <expression> ]
* new <expression> [ <expression> ] ( <expression> )
n := new bool[count];
foreach i in n do i := false
"string".size

### Multiple expressions

* <expression> ; <expression>
* <expression> ; <expression> ;
* { }
* { <expression> }

### Conditionals

* __if__ <expression> __then__ <expression>
* __if__ <expression> __then__ <expression> else <expression>

### Loops

Loops are void expressions.

* __for__ <expression>, __order__ <expression> __asc__, step
  <expression> __do__ <expression>
* __while__ <expression> __do__ <expression>
* __do__ <expression> __while__ <expression>
