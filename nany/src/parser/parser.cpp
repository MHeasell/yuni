//
//
// Generated by Nany's parser.cpp engine (modified from Kessel's C engine)
//
//


#include <cstdio>
#include <cstdlib>
#include <cwchar>                  // wchar_t
#include <sys/stat.h>
#include <cassert>
#include <iostream>

extern "C"
{
#include "engine.h"                 // The Kessels engine.
#include "grammar.h"                // Generated by GOLD.
} // extern "C"
#include "parser.h"
#include "yuni/yuni.h"
#include "yuni/core/string.h"
#include "../ast/all.h"
#include "../ast/type.h"


#define TRIMREDUCTIONS 0            // 0=off, 1=on




// Forward declaration of generic routines for symbol management or rule propagation
template<class NodeT = Nany::Ast::Node>
static NodeT* ParseChild(struct TokenStruct* token, unsigned int index);
static const wchar_t* GetChildSymbol(struct TokenStruct* token, unsigned int index);



///// Helper subroutines



// Make a readable copy of a string. All characters outside 32...127 are
// displayed as a HEX number in square brackets, for example "[0A]".
static void ReadableString(wchar_t* input, wchar_t* output, long width)
{
	// Sanity check.
	if (!output || (width < 1))
		return;
	output[0] = 0;
	if (input == NULL)
		return;

	long i1 = 0;
	long i2 = 0;
	while ((i2 < width - 1) && (input[i1] != 0))
	{
		if ((input[i1] >= 32) && (input[i1] <= 127))
		{
			output[i2++] = input[i1];
		}
		else
		{
			if (width - i2 > 4)
			{
				char s1[BUFSIZ];
				sprintf(s1, "%02X", input[i1]);
				output[i2++] = '[';
				output[i2++] = s1[0];
				output[i2++] = s1[1];
				output[i2++] = ']';
			}
		}
		i1++;
	}
	output[i2] = 0;
}




///// Rule subroutines




// <Program> ::= <Unit Declaration> <Dependencies> <Declaration List>
Nany::Ast::Node* Rule_Program(struct TokenStruct* token)
{
	Nany::Ast::UnitDeclarationNode* unitDecl = ParseChild<Nany::Ast::UnitDeclarationNode>(token, 0);
	Nany::Ast::DeclarationListNode* declarations = ParseChild<Nany::Ast::DeclarationListNode>(token, 2);

	return new Nany::Ast::ProgramNode(unitDecl, declarations);
}




// <Unit Declaration> ::= <Optional Visibility Qualifier> unit Identifier ';'
Nany::Ast::Node* Rule_UnitDeclaration_unit_Identifier_Semi(struct TokenStruct* token)
{
	// TODO : handle visibility qualifiers

	Nany::Ast::Node* node = new Nany::Ast::UnitDeclarationNode(false, GetChildSymbol(token, 2));
	return node;
}




// <Unit Declaration> ::= program Identifier ';'
Nany::Ast::Node* Rule_UnitDeclaration_program_Identifier_Semi(struct TokenStruct* token)
{
	Nany::Ast::Node* node = new Nany::Ast::UnitDeclarationNode(true, GetChildSymbol(token, 1));
	return node;
}




// <Dependencies> ::= <Dependency> <Dependencies>
Nany::Ast::Node* Rule_Dependencies(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Dependencies> ::= 
Nany::Ast::Node* Rule_Dependencies2(struct TokenStruct* token)
{
	return nullptr;
}




// <Dependency> ::= uses Identifier <Dependency Continued> ';'
Nany::Ast::Node* Rule_Dependency_uses_Identifier_Semi(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Dependency Continued> ::= '.' Identifier <Dependency Continued>
Nany::Ast::Node* Rule_DependencyContinued_Dot_Identifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Dependency Continued> ::= 
Nany::Ast::Node* Rule_DependencyContinued(struct TokenStruct* token)
{
	return nullptr;
}




// <Declaration List> ::= <Function Declaration> <Declaration List>
Nany::Ast::Node* Rule_DeclarationList(struct TokenStruct* token)
{
	Nany::Ast::FunctionDeclarationNode* funcDecl = ParseChild<Nany::Ast::FunctionDeclarationNode>(token, 0);

	Nany::Ast::DeclarationListNode* declList = ParseChild<Nany::Ast::DeclarationListNode>(token, 1);
	declList->prepend(funcDecl);

	return declList;
}




// <Declaration List> ::= <Optional Visibility Qualifier> <Class Declaration> <Declaration List>
Nany::Ast::Node* Rule_DeclarationList2(struct TokenStruct* token)
{
	// TODO : Handle classes

	Nany::Ast::DeclarationListNode* declList = ParseChild<Nany::Ast::DeclarationListNode>(token, 2);
	return declList;
}




// <Declaration List> ::= <Optional Visibility Qualifier> <Workflow Declaration> <Declaration List>
Nany::Ast::Node* Rule_DeclarationList3(struct TokenStruct* token)
{
	// TODO : Handle workflows

	Nany::Ast::DeclarationListNode* declList = ParseChild<Nany::Ast::DeclarationListNode>(token, 2);
	return declList;
}




// <Declaration List> ::= <Optional Visibility Qualifier> <Enum Declaration> <Declaration List>
Nany::Ast::Node* Rule_DeclarationList4(struct TokenStruct* token)
{
	// TODO : Handle enums

	Nany::Ast::DeclarationListNode* declList = ParseChild<Nany::Ast::DeclarationListNode>(token, 2);
	return declList;
}




// <Declaration List> ::= 
Nany::Ast::Node* Rule_DeclarationList5(struct TokenStruct* token)
{
	return new Nany::Ast::DeclarationListNode();
}




// <Literal> ::= BooleanLiteral
Nany::Ast::Node* Rule_Literal_BooleanLiteral(struct TokenStruct* token)
{
	const wchar_t* data = GetChildSymbol(token, 0);
	return new Nany::Ast::LiteralNode<bool>(L't' == data[0]);
}




// <Literal> ::= DecLiteral
Nany::Ast::Node* Rule_Literal_DecLiteral(struct TokenStruct* token)
{
	Yuni::String data(GetChildSymbol(token, 0));
	bool isUnsigned = data[data.size() - 1] == 'u' || (data.size() > 1 && data[data.size() - 2] == 'u')
		|| data[data.size() - 1] == 'U' || (data.size() > 1 && data[data.size() - 2] == 'U');
	if (isUnsigned)
		return new Nany::Ast::LiteralNode<unsigned int>(data.to<unsigned int>());
	else
		return new Nany::Ast::LiteralNode<int>(data.to<int>());
}




// <Literal> ::= HexLiteral
Nany::Ast::Node* Rule_Literal_HexLiteral(struct TokenStruct* token)
{
	const wchar_t* symbol = GetChildSymbol(token, 0);
	size_t len = wcslen(symbol);
	char* buffer = new char[len];
	wcstombs(buffer, symbol, len);
	Yuni::String data(buffer);
	bool isUnsigned = data[data.size() - 1] == 'u' || (data.size() > 1 && data[data.size() - 2] == 'u')
		|| data[data.size() - 1] == 'U' || (data.size() > 1 && data[data.size() - 2] == 'U');
	if (isUnsigned)
		return new Nany::Ast::LiteralNode<unsigned int>(data.to<unsigned int>());
	else
		return new Nany::Ast::LiteralNode<int>(data.to<int>());
}




// <Literal> ::= RealLiteral
Nany::Ast::Node* Rule_Literal_RealLiteral(struct TokenStruct* token)
{
	Yuni::String data(GetChildSymbol(token, 0));
	return new Nany::Ast::LiteralNode<int>(data.to<float>());
}




// <Literal> ::= TimeLiteral
Nany::Ast::Node* Rule_Literal_TimeLiteral(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Literal> ::= CharLiteral
Nany::Ast::Node* Rule_Literal_CharLiteral(struct TokenStruct* token)
{
	// FIXME : Conversion from wchar_t to char problem ?
	return new Nany::Ast::LiteralNode<char>(GetChildSymbol(token, 0)[0]);
}




// <Literal> ::= StringLiteral
Nany::Ast::Node* Rule_Literal_StringLiteral(struct TokenStruct* token)
{
	const wchar_t* symbol = GetChildSymbol(token, 0);
	size_t len = wcslen(symbol);
	char* buffer = new char[len + 1];
	wcstombs(buffer, symbol, len);
	buffer[len] = 0;
	return new Nany::Ast::LiteralNode<const char*>(buffer);
}




// <Literal> ::= BuiltInType
Nany::Ast::Node* Rule_Literal_BuiltInType(struct TokenStruct* token)
{
	const wchar_t* symbol = GetChildSymbol(token, 0);
	size_t len = wcslen(symbol);
	char* buffer = new char[len + 1];
	wcstombs(buffer, symbol, len);
	buffer[len] = 0;

	Nany::Ast::Type* typeObject = Nany::Ast::Type::Get(buffer);
	assert(nullptr != typeObject && "Built-in type was not recognized !");

	Nany::Ast::LiteralNode<Nany::Ast::Type*>* literalNode = new Nany::Ast::LiteralNode<Nany::Ast::Type*>(typeObject);
	literalNode->type(typeObject);
	Nany::Ast::TypeExpressionNode* result = new Nany::Ast::TypeExpressionNode(literalNode);
	result->type(typeObject);
	return result;
}




// <Literal> ::= nil
Nany::Ast::Node* Rule_Literal_nil(struct TokenStruct* token)
{
	return new Nany::Ast::LiteralNode<void*>(nullptr);
}




// <Literal> ::= self
Nany::Ast::Node* Rule_Literal_self(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Class Declaration> ::= class Identifier <Optional Type Parameters> <In Block> <Out Block> '{' <Class Content> '}'
Nany::Ast::Node* Rule_ClassDeclaration_class_Identifier_LBrace_RBrace(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Class Content> ::= VisibilityQualifier <Class Content>
Nany::Ast::Node* Rule_ClassContent_VisibilityQualifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Class Content> ::= <Method Declaration> <Class Content>
Nany::Ast::Node* Rule_ClassContent(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Class Content> ::= <Attribute Declaration> ';' <Class Content>
Nany::Ast::Node* Rule_ClassContent_Semi(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Class Content> ::= <Property Declaration> ';' <Class Content>
Nany::Ast::Node* Rule_ClassContent_Semi2(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Class Content> ::= <Class Declaration> <Class Content>
Nany::Ast::Node* Rule_ClassContent2(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Class Content> ::= 
Nany::Ast::Node* Rule_ClassContent3(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Property Declaration> ::= property Identifier <Optional Typing> <Optional Assignment> <Property Callbacks>
Nany::Ast::Node* Rule_PropertyDeclaration_property_Identifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Property Callbacks> ::= read <SingleThread Exp> <Property Callbacks>
Nany::Ast::Node* Rule_PropertyCallbacks_read(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Property Callbacks> ::= write <SingleThread Exp> <Property Callbacks>
Nany::Ast::Node* Rule_PropertyCallbacks_write(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Property Callbacks> ::= 
Nany::Ast::Node* Rule_PropertyCallbacks(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Attribute Declaration> ::= attribute Identifier <Optional Typing> <Optional Assignment>
Nany::Ast::Node* Rule_AttributeDeclaration_attribute_Identifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Attribute Declaration> ::= ConstQualifier attribute Identifier <Optional Typing> <Optional Assignment>
Nany::Ast::Node* Rule_AttributeDeclaration_ConstQualifier_attribute_Identifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Optional Assignment> ::= ':=' <Expression>
Nany::Ast::Node* Rule_OptionalAssignment_ColonEq(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Optional Assignment> ::= 
Nany::Ast::Node* Rule_OptionalAssignment(struct TokenStruct* token)
{
	return nullptr;
}




// <Optional Typing> ::= ':' <Type Qualifiers> <SingleThread Exp>
Nany::Ast::Node* Rule_OptionalTyping_Colon(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Optional Typing> ::= 
Nany::Ast::Node* Rule_OptionalTyping(struct TokenStruct* token)
{
	return nullptr;
}




// <Workflow Declaration> ::= workflow Identifier '{' <Workflow Content> '}'
Nany::Ast::Node* Rule_WorkflowDeclaration_workflow_Identifier_LBrace_RBrace(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Workflow Content> ::= <State Block> <Transition Block>
Nany::Ast::Node* Rule_WorkflowContent(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <State Block> ::= states <Workflow States>
Nany::Ast::Node* Rule_StateBlock_states(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <State Block> ::= 
Nany::Ast::Node* Rule_StateBlock(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Workflow States> ::= default Identifier ';' <Workflow States>
Nany::Ast::Node* Rule_WorkflowStates_default_Identifier_Semi(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Workflow States> ::= state Identifier ';' <Workflow States>
Nany::Ast::Node* Rule_WorkflowStates_state_Identifier_Semi(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Workflow States> ::= 
Nany::Ast::Node* Rule_WorkflowStates(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Transition Block> ::= transitions <Workflow Transitions>
Nany::Ast::Node* Rule_TransitionBlock_transitions(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Transition Block> ::= 
Nany::Ast::Node* Rule_TransitionBlock(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Workflow Transitions> ::= default allow ';' <Workflow Transitions>
Nany::Ast::Node* Rule_WorkflowTransitions_default_allow_Semi(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Workflow Transitions> ::= default forbid ';' <Workflow Transitions>
Nany::Ast::Node* Rule_WorkflowTransitions_default_forbid_Semi(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Workflow Transitions> ::= allow <Workflow Permissions> '=>' <Workflow Permissions> ';' <Workflow Transitions>
Nany::Ast::Node* Rule_WorkflowTransitions_allow_EqGt_Semi(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Workflow Transitions> ::= forbid <Workflow Permissions> '=>' <Workflow Permissions> ';' <Workflow Transitions>
Nany::Ast::Node* Rule_WorkflowTransitions_forbid_EqGt_Semi(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Workflow Transitions> ::= 
Nany::Ast::Node* Rule_WorkflowTransitions(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Workflow Permission> ::= '*'
Nany::Ast::Node* Rule_WorkflowPermission_Times(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Workflow Permission> ::= Identifier
Nany::Ast::Node* Rule_WorkflowPermission_Identifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Workflow Permission> ::= '+' Identifier
Nany::Ast::Node* Rule_WorkflowPermission_Plus_Identifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Workflow Permission> ::= '-' Identifier
Nany::Ast::Node* Rule_WorkflowPermission_Minus_Identifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Workflow Permissions> ::= <Workflow Permission> ',' <Workflow Permissions>
Nany::Ast::Node* Rule_WorkflowPermissions_Comma(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Workflow Permissions> ::= <Workflow Permission>
Nany::Ast::Node* Rule_WorkflowPermissions(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Enum Declaration> ::= enum Identifier '{' <Enum Content> '}'
Nany::Ast::Node* Rule_EnumDeclaration_enum_Identifier_LBrace_RBrace(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Enum Content> ::= Identifier ',' <Enum Content>
Nany::Ast::Node* Rule_EnumContent_Identifier_Comma(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Enum Content> ::= Identifier
Nany::Ast::Node* Rule_EnumContent_Identifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Enum Content> ::= 
Nany::Ast::Node* Rule_EnumContent(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Function Declaration> ::= <Optional Optim Qualifier> function Identifier <Optional Type Parameters> <Optional Parameters> <Return Type Declaration> <In Block> <Out Block> '{' <Expression> '}'
Nany::Ast::Node* Rule_FunctionDeclaration_function_Identifier_LBrace_RBrace(struct TokenStruct* token)
{
	// Read the body of the function
	Nany::Ast::Node* bodyExpr = ParseChild<Nany::Ast::Node>(token, 9);
	Nany::Ast::ScopeNode* body = new Nany::Ast::ScopeNode(bodyExpr);

	// TODO : Almost everything... optims, parameters, in and out blocks

	Nany::Ast::TypeExpressionNode* returnType = ParseChild<Nany::Ast::TypeExpressionNode>(token, 5);

	// Read the name of the function
	const wchar_t* funcName = GetChildSymbol(token, 2);
	size_t len = wcslen(funcName);
	char* buffer = new char[len + 1];
	wcstombs(buffer, funcName, len);
	buffer[len] = 0;

	Nany::Ast::Node* result = new Nany::Ast::FunctionDeclarationNode(buffer, body, returnType);
	return result;
}




// <Method Declaration> ::= <Optional Optim Qualifier> method Identifier <Optional Type Parameters> <Optional Parameters> <Return Type Declaration> <In Block> <Out Block> '{' <Expression> '}'
Nany::Ast::Node* Rule_MethodDeclaration_method_Identifier_LBrace_RBrace(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Return Type Declaration> ::= ':' <Expression>
Nany::Ast::Node* Rule_ReturnTypeDeclaration_Colon(struct TokenStruct* token)
{
	return new Nany::Ast::TypeExpressionNode(ParseChild<>(token, 1));
}




// <Return Type Declaration> ::= 
Nany::Ast::Node* Rule_ReturnTypeDeclaration(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Optional Parameters> ::= '(' <Parameter List> ')'
Nany::Ast::Node* Rule_OptionalParameters_LParan_RParan(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Optional Parameters> ::= 
Nany::Ast::Node* Rule_OptionalParameters(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Parameter List> ::= Identifier <Optional Typing> <Optional Assignment> <Parameter List Continued>
Nany::Ast::Node* Rule_ParameterList_Identifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Parameter List> ::= 
Nany::Ast::Node* Rule_ParameterList(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Parameter List Continued> ::= ',' <Parameter List>
Nany::Ast::Node* Rule_ParameterListContinued_Comma(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Parameter List Continued> ::= 
Nany::Ast::Node* Rule_ParameterListContinued(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Type Qualifiers> ::= TypeQualifier <Type Qualifiers Continued>
Nany::Ast::Node* Rule_TypeQualifiers_TypeQualifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Type Qualifiers> ::= 
Nany::Ast::Node* Rule_TypeQualifiers(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Type Qualifiers Continued> ::= TypeQualifier <Type Qualifiers Continued>
Nany::Ast::Node* Rule_TypeQualifiersContinued_TypeQualifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Type Qualifiers Continued> ::= 
Nany::Ast::Node* Rule_TypeQualifiersContinued(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Optional Optim Qualifier> ::= OptimQualifier
Nany::Ast::Node* Rule_OptionalOptimQualifier_OptimQualifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Optional Optim Qualifier> ::= 
Nany::Ast::Node* Rule_OptionalOptimQualifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Optional Visibility Qualifier> ::= VisibilityQualifier
Nany::Ast::Node* Rule_OptionalVisibilityQualifier_VisibilityQualifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Optional Visibility Qualifier> ::= 
Nany::Ast::Node* Rule_OptionalVisibilityQualifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Argument List> ::= <Expression> <Argument List Continued>
Nany::Ast::Node* Rule_ArgumentList(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Argument List> ::= 
Nany::Ast::Node* Rule_ArgumentList2(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Argument List Continued> ::= ',' <Expression>
Nany::Ast::Node* Rule_ArgumentListContinued_Comma(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Argument List Continued> ::= 
Nany::Ast::Node* Rule_ArgumentListContinued(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <In Block> ::= in <Expression>
Nany::Ast::Node* Rule_InBlock_in(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <In Block> ::= 
Nany::Ast::Node* Rule_InBlock(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Out Block> ::= out <Expression>
Nany::Ast::Node* Rule_OutBlock_out(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Out Block> ::= 
Nany::Ast::Node* Rule_OutBlock(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Optional Type Parameters> ::= '<' <Type Parameters>
Nany::Ast::Node* Rule_OptionalTypeParameters_Lt(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Optional Type Parameters> ::= 
Nany::Ast::Node* Rule_OptionalTypeParameters(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Type Parameters> ::= Identifier <Type Parameters Continued> '>'
Nany::Ast::Node* Rule_TypeParameters_Identifier_Gt(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Type Parameters> ::= Identifier ':=' <Expression> <Type Parameters Continued> '>'
Nany::Ast::Node* Rule_TypeParameters_Identifier_ColonEq_Gt(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Type Parameters Continued> ::= ',' Identifier <Type Parameters Continued>
Nany::Ast::Node* Rule_TypeParametersContinued_Comma_Identifier(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Type Parameters Continued> ::= ',' Identifier ':=' <Expression> <Type Parameters Continued>
Nany::Ast::Node* Rule_TypeParametersContinued_Comma_Identifier_ColonEq(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Type Parameters Continued> ::= 
Nany::Ast::Node* Rule_TypeParametersContinued(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Type Arguments> ::= <Expression> <Type Arguments Continued> '>'
Nany::Ast::Node* Rule_TypeArguments_Gt(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Type Arguments Continued> ::= ',' <Expression> <Type Parameters Continued>
Nany::Ast::Node* Rule_TypeArgumentsContinued_Comma(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Type Arguments Continued> ::= 
Nany::Ast::Node* Rule_TypeArgumentsContinued(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Expression> ::= <Possibly Parallel Exp> <Expression List>
Nany::Ast::Node* Rule_Expression(struct TokenStruct* token)
{
	Nany::Ast::Node* expr = ParseChild<>(token, 0);
	Nany::Ast::Node* recursive = ParseChild<Nany::Ast::Node>(token, 1);

	if (!recursive)
		return expr;

	Nany::Ast::ExpressionListNode* list = dynamic_cast<Nany::Ast::ExpressionListNode*>(recursive);
	if (!list)
	{
		list = new Nany::Ast::ExpressionListNode();
		list->prepend(expr);
	}
	return list;
}




// <Expression List> ::= ';' <Expression>
Nany::Ast::Node* Rule_ExpressionList_Semi(struct TokenStruct* token)
{
	return ParseChild<Nany::Ast::ExpressionListNode>(token, 1);
}




// <Expression List> ::= 
Nany::Ast::Node* Rule_ExpressionList(struct TokenStruct* token)
{
	return nullptr;
}




// <Possibly Parallel Exp> ::= <SingleThread Exp>
Nany::Ast::Node* Rule_PossiblyParallelExp(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <Possibly Parallel Exp> ::= '&' <SingleThread Exp>
Nany::Ast::Node* Rule_PossiblyParallelExp_Amp(struct TokenStruct* token)
{
	Nany::Ast::Node* child = ParseChild<>(token, 0);
	return new Nany::Ast::ParallelExpressionNode(child);
}




// <SingleThread Exp> ::= <Assignment Exp>
Nany::Ast::Node* Rule_SingleThreadExp(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <Assignment Exp> ::= <Simple Exp> <Optional Typing> <Optional Assignment>
Nany::Ast::Node* Rule_AssignmentExp(struct TokenStruct* token)
{
	// TODO : assignment

	return ParseChild<>(token, 0);
}




// <Simple Exp> ::= <Binary Exp>
Nany::Ast::Node* Rule_SimpleExp(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <Simple Exp> ::= return <SingleThread Exp>
Nany::Ast::Node* Rule_SimpleExp_return(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Simple Exp> ::= typeof <SingleThread Exp>
Nany::Ast::Node* Rule_SimpleExp_typeof(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Simple Exp> ::= break
Nany::Ast::Node* Rule_SimpleExp_break(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Simple Exp> ::= continue
Nany::Ast::Node* Rule_SimpleExp_continue(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Simple Exp> ::= <Attribute Declaration>
Nany::Ast::Node* Rule_SimpleExp2(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <Simple Exp> ::= if <Expression> then <Expression> <Else Expression>
Nany::Ast::Node* Rule_SimpleExp_if_then(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Simple Exp> ::= while <Expression> do <Expression>
Nany::Ast::Node* Rule_SimpleExp_while_do(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Simple Exp> ::= for Identifier in <Expression> do <Expression>
Nany::Ast::Node* Rule_SimpleExp_for_Identifier_in_do(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Simple Exp> ::= for Identifier in <Expression> order ':' <Expression> packedby ':' <Expression> do <Expression>
Nany::Ast::Node* Rule_SimpleExp_for_Identifier_in_order_Colon_packedby_Colon_do(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Simple Exp> ::= for Identifier in <Expression> order do <Expression>
Nany::Ast::Node* Rule_SimpleExp_for_Identifier_in_order_do(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Simple Exp> ::= timeout <Expression> do <Expression>
Nany::Ast::Node* Rule_SimpleExp_timeout_do(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Simple Exp> ::= timeout <Expression> do <Expression> else <Expression>
Nany::Ast::Node* Rule_SimpleExp_timeout_do_else(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Simple Exp> ::= '{' <Expression> '}'
Nany::Ast::Node* Rule_SimpleExp_LBrace_RBrace(struct TokenStruct* token)
{
	// TODO : add an expressionlistnode inside a scope
	return ParseChild<>(token, 0);
}




// <Else Expression> ::= else <Expression>
Nany::Ast::Node* Rule_ElseExpression_else(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Else Expression> ::= 
Nany::Ast::Node* Rule_ElseExpression(struct TokenStruct* token)
{
	return nullptr;
}




// <Binary Exp> ::= <SingleThread Exp> '|' <Xor Exp>
Nany::Ast::Node* Rule_BinaryExp_Pipe(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Binary Exp> ::= <Xor Exp>
Nany::Ast::Node* Rule_BinaryExp(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <Xor Exp> ::= <Xor Exp> xor <Or Exp>
Nany::Ast::Node* Rule_XorExp_xor(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Xor Exp> ::= <Or Exp>
Nany::Ast::Node* Rule_XorExp(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <Or Exp> ::= <Or Exp> or <And Exp>
Nany::Ast::Node* Rule_OrExp_or(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Or Exp> ::= <And Exp>
Nany::Ast::Node* Rule_OrExp(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <And Exp> ::= <And Exp> and <Compare Exp>
Nany::Ast::Node* Rule_AndExp_and(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <And Exp> ::= <Equal Exp>
Nany::Ast::Node* Rule_AndExp(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <Equal Exp> ::= <Equal Exp> '=' <Compare Exp>
Nany::Ast::Node* Rule_EqualExp_Eq(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Equal Exp> ::= <Equal Exp> '!=' <Compare Exp>
Nany::Ast::Node* Rule_EqualExp_ExclamEq(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Equal Exp> ::= <Compare Exp>
Nany::Ast::Node* Rule_EqualExp(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <Compare Exp> ::= <Compare Exp> '>' <Regexp Exp>
Nany::Ast::Node* Rule_CompareExp_Gt(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Compare Exp> ::= <Compare Exp> '<=' <Regexp Exp>
Nany::Ast::Node* Rule_CompareExp_LtEq(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Compare Exp> ::= <Compare Exp> '>=' <Regexp Exp>
Nany::Ast::Node* Rule_CompareExp_GtEq(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Compare Exp> ::= <Inferior Exp>
Nany::Ast::Node* Rule_CompareExp(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <Compare Exp> ::= <Regexp Exp>
Nany::Ast::Node* Rule_CompareExp2(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <Inferior Exp> ::= <Compare Exp> '<' <Regexp Exp>
Nany::Ast::Node* Rule_InferiorExp_Lt(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Regexp Exp> ::= <Regexp Exp> '~' <Shift Exp>
Nany::Ast::Node* Rule_RegexpExp_Tilde(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Regexp Exp> ::= <Shift Exp>
Nany::Ast::Node* Rule_RegexpExp(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <Shift Exp> ::= <Shift Exp> '<<' <Add Exp>
Nany::Ast::Node* Rule_ShiftExp_LtLt(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Shift Exp> ::= <Shift Exp> '>>' <Add Exp>
Nany::Ast::Node* Rule_ShiftExp_GtGt(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Shift Exp> ::= <Add Exp>
Nany::Ast::Node* Rule_ShiftExp(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <Add Exp> ::= <Add Exp> '+' <Mult Exp>
Nany::Ast::Node* Rule_AddExp_Plus(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Add Exp> ::= <Add Exp> '-' <Mult Exp>
Nany::Ast::Node* Rule_AddExp_Minus(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Add Exp> ::= <Mult Exp>
Nany::Ast::Node* Rule_AddExp(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <Mult Exp> ::= <Mult Exp> '*' <Power Exp>
Nany::Ast::Node* Rule_MultExp_Times(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Mult Exp> ::= <Mult Exp> '/' <Power Exp>
Nany::Ast::Node* Rule_MultExp_Div(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Mult Exp> ::= <Power Exp>
Nany::Ast::Node* Rule_MultExp(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <Power Exp> ::= <Power Exp> '^' <Negate Exp>
Nany::Ast::Node* Rule_PowerExp_Caret(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Power Exp> ::= <Negate Exp>
Nany::Ast::Node* Rule_PowerExp(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <Negate Exp> ::= '-' <Value>
Nany::Ast::Node* Rule_NegateExp_Minus(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Negate Exp> ::= -- <Value>
Nany::Ast::Node* Rule_NegateExp_MinusMinus(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Negate Exp> ::= '++' <Value>
Nany::Ast::Node* Rule_NegateExp_PlusPlus(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Negate Exp> ::= <Value> --
Nany::Ast::Node* Rule_NegateExp_MinusMinus2(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Negate Exp> ::= <Value> '++'
Nany::Ast::Node* Rule_NegateExp_PlusPlus2(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Negate Exp> ::= <Value>
Nany::Ast::Node* Rule_NegateExp(struct TokenStruct* token)
{
	return ParseChild<>(token, 0);
}




// <Value> ::= <Literal> <Subscript>
Nany::Ast::Node* Rule_Value(struct TokenStruct* token)
{
	// TODO : Handle subscripts
	return ParseChild<>(token, 0);
}




// <Value> ::= '(' <SingleThread Exp> ')' <Subscript>
Nany::Ast::Node* Rule_Value_LParan_RParan(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Value> ::= Identifier <Subscript>
Nany::Ast::Node* Rule_Value_Identifier(struct TokenStruct* token)
{
	Nany::Ast::Node* child1 = ParseChild<Nany::Ast::Node>(token, 1);
	if (nullptr != child1)
		return child1; // TODO: handle subscripts

	return new Nany::Ast::IdentifierNode(GetChildSymbol(token, 0));
}




// <Subscript> ::=
Nany::Ast::Node* Rule_Subscript(struct TokenStruct* token)
{
	return nullptr;
}




// <Subscript> ::= '.' <Value>
Nany::Ast::Node* Rule_Subscript_Dot(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




// <Subscript> ::= '(' <Argument List> ')'
Nany::Ast::Node* Rule_Subscript_LParan_RParan(struct TokenStruct* token)
{
	// Not yet implemented !
	assert(false && "Not yet implemented !");
}




///// Rule jumptable




Nany::Ast::Node* (*RuleJumpTable[])(struct TokenStruct* token) =
{
	// 0. <Program> ::= <Unit Declaration> <Dependencies> <Declaration List>
	Rule_Program,
	// 1. <Unit Declaration> ::= <Optional Visibility Qualifier> unit Identifier ';'
	Rule_UnitDeclaration_unit_Identifier_Semi,
	// 2. <Unit Declaration> ::= program Identifier ';'
	Rule_UnitDeclaration_program_Identifier_Semi,
	// 3. <Dependencies> ::= <Dependency> <Dependencies>
	Rule_Dependencies,
	// 4. <Dependencies> ::= 
	Rule_Dependencies2,
	// 5. <Dependency> ::= uses Identifier <Dependency Continued> ';'
	Rule_Dependency_uses_Identifier_Semi,
	// 6. <Dependency Continued> ::= '.' Identifier <Dependency Continued>
	Rule_DependencyContinued_Dot_Identifier,
	// 7. <Dependency Continued> ::= 
	Rule_DependencyContinued,
	// 8. <Declaration List> ::= <Function Declaration> <Declaration List>
	Rule_DeclarationList,
	// 9. <Declaration List> ::= <Optional Visibility Qualifier> <Class Declaration> <Declaration List>
	Rule_DeclarationList2,
	// 10. <Declaration List> ::= <Optional Visibility Qualifier> <Workflow Declaration> <Declaration List>
	Rule_DeclarationList3,
	// 11. <Declaration List> ::= <Optional Visibility Qualifier> <Enum Declaration> <Declaration List>
	Rule_DeclarationList4,
	// 12. <Declaration List> ::= 
	Rule_DeclarationList5,
	// 13. <Literal> ::= BooleanLiteral
	Rule_Literal_BooleanLiteral,
	// 14. <Literal> ::= DecLiteral
	Rule_Literal_DecLiteral,
	// 15. <Literal> ::= HexLiteral
	Rule_Literal_HexLiteral,
	// 16. <Literal> ::= RealLiteral
	Rule_Literal_RealLiteral,
	// 17. <Literal> ::= TimeLiteral
	Rule_Literal_TimeLiteral,
	// 18. <Literal> ::= CharLiteral
	Rule_Literal_CharLiteral,
	// 19. <Literal> ::= StringLiteral
	Rule_Literal_StringLiteral,
	// 20. <Literal> ::= BuiltInType
	Rule_Literal_BuiltInType,
	// 21. <Literal> ::= nil
	Rule_Literal_nil,
	// 22. <Literal> ::= self
	Rule_Literal_self,
	// 23. <Class Declaration> ::= class Identifier <Optional Type Parameters> <In Block> <Out Block> '{' <Class Content> '}'
	Rule_ClassDeclaration_class_Identifier_LBrace_RBrace,
	// 24. <Class Content> ::= VisibilityQualifier <Class Content>
	Rule_ClassContent_VisibilityQualifier,
	// 25. <Class Content> ::= <Method Declaration> <Class Content>
	Rule_ClassContent,
	// 26. <Class Content> ::= <Attribute Declaration> ';' <Class Content>
	Rule_ClassContent_Semi,
	// 27. <Class Content> ::= <Property Declaration> ';' <Class Content>
	Rule_ClassContent_Semi2,
	// 28. <Class Content> ::= <Class Declaration> <Class Content>
	Rule_ClassContent2,
	// 29. <Class Content> ::= 
	Rule_ClassContent3,
	// 30. <Property Declaration> ::= property Identifier <Optional Typing> <Optional Assignment> <Property Callbacks>
	Rule_PropertyDeclaration_property_Identifier,
	// 31. <Property Callbacks> ::= read <SingleThread Exp> <Property Callbacks>
	Rule_PropertyCallbacks_read,
	// 32. <Property Callbacks> ::= write <SingleThread Exp> <Property Callbacks>
	Rule_PropertyCallbacks_write,
	// 33. <Property Callbacks> ::= 
	Rule_PropertyCallbacks,
	// 34. <Attribute Declaration> ::= attribute Identifier <Optional Typing> <Optional Assignment>
	Rule_AttributeDeclaration_attribute_Identifier,
	// 35. <Attribute Declaration> ::= ConstQualifier attribute Identifier <Optional Typing> <Optional Assignment>
	Rule_AttributeDeclaration_ConstQualifier_attribute_Identifier,
	// 36. <Optional Assignment> ::= ':=' <Expression>
	Rule_OptionalAssignment_ColonEq,
	// 37. <Optional Assignment> ::= 
	Rule_OptionalAssignment,
	// 38. <Optional Typing> ::= ':' <Type Qualifiers> <SingleThread Exp>
	Rule_OptionalTyping_Colon,
	// 39. <Optional Typing> ::= 
	Rule_OptionalTyping,
	// 40. <Workflow Declaration> ::= workflow Identifier '{' <Workflow Content> '}'
	Rule_WorkflowDeclaration_workflow_Identifier_LBrace_RBrace,
	// 41. <Workflow Content> ::= <State Block> <Transition Block>
	Rule_WorkflowContent,
	// 42. <State Block> ::= states <Workflow States>
	Rule_StateBlock_states,
	// 43. <State Block> ::= 
	Rule_StateBlock,
	// 44. <Workflow States> ::= default Identifier ';' <Workflow States>
	Rule_WorkflowStates_default_Identifier_Semi,
	// 45. <Workflow States> ::= state Identifier ';' <Workflow States>
	Rule_WorkflowStates_state_Identifier_Semi,
	// 46. <Workflow States> ::= 
	Rule_WorkflowStates,
	// 47. <Transition Block> ::= transitions <Workflow Transitions>
	Rule_TransitionBlock_transitions,
	// 48. <Transition Block> ::= 
	Rule_TransitionBlock,
	// 49. <Workflow Transitions> ::= default allow ';' <Workflow Transitions>
	Rule_WorkflowTransitions_default_allow_Semi,
	// 50. <Workflow Transitions> ::= default forbid ';' <Workflow Transitions>
	Rule_WorkflowTransitions_default_forbid_Semi,
	// 51. <Workflow Transitions> ::= allow <Workflow Permissions> '=>' <Workflow Permissions> ';' <Workflow Transitions>
	Rule_WorkflowTransitions_allow_EqGt_Semi,
	// 52. <Workflow Transitions> ::= forbid <Workflow Permissions> '=>' <Workflow Permissions> ';' <Workflow Transitions>
	Rule_WorkflowTransitions_forbid_EqGt_Semi,
	// 53. <Workflow Transitions> ::= 
	Rule_WorkflowTransitions,
	// 54. <Workflow Permission> ::= '*'
	Rule_WorkflowPermission_Times,
	// 55. <Workflow Permission> ::= Identifier
	Rule_WorkflowPermission_Identifier,
	// 56. <Workflow Permission> ::= '+' Identifier
	Rule_WorkflowPermission_Plus_Identifier,
	// 57. <Workflow Permission> ::= '-' Identifier
	Rule_WorkflowPermission_Minus_Identifier,
	// 58. <Workflow Permissions> ::= <Workflow Permission> ',' <Workflow Permissions>
	Rule_WorkflowPermissions_Comma,
	// 59. <Workflow Permissions> ::= <Workflow Permission>
	Rule_WorkflowPermissions,
	// 60. <Enum Declaration> ::= enum Identifier '{' <Enum Content> '}'
	Rule_EnumDeclaration_enum_Identifier_LBrace_RBrace,
	// 61. <Enum Content> ::= Identifier ',' <Enum Content>
	Rule_EnumContent_Identifier_Comma,
	// 62. <Enum Content> ::= Identifier
	Rule_EnumContent_Identifier,
	// 63. <Enum Content> ::= 
	Rule_EnumContent,
	// 64. <Function Declaration> ::= <Optional Optim Qualifier> function Identifier <Optional Type Parameters> <Optional Parameters> <Return Type Declaration> <In Block> <Out Block> '{' <Expression> '}'
	Rule_FunctionDeclaration_function_Identifier_LBrace_RBrace,
	// 65. <Method Declaration> ::= <Optional Optim Qualifier> method Identifier <Optional Type Parameters> <Optional Parameters> <Return Type Declaration> <In Block> <Out Block> '{' <Expression> '}'
	Rule_MethodDeclaration_method_Identifier_LBrace_RBrace,
	// 66. <Return Type Declaration> ::= ':' <Expression>
	Rule_ReturnTypeDeclaration_Colon,
	// 67. <Return Type Declaration> ::= 
	Rule_ReturnTypeDeclaration,
	// 68. <Optional Parameters> ::= '(' <Parameter List> ')'
	Rule_OptionalParameters_LParan_RParan,
	// 69. <Optional Parameters> ::= 
	Rule_OptionalParameters,
	// 70. <Parameter List> ::= Identifier <Optional Typing> <Optional Assignment> <Parameter List Continued>
	Rule_ParameterList_Identifier,
	// 71. <Parameter List> ::= 
	Rule_ParameterList,
	// 72. <Parameter List Continued> ::= ',' <Parameter List>
	Rule_ParameterListContinued_Comma,
	// 73. <Parameter List Continued> ::= 
	Rule_ParameterListContinued,
	// 74. <Type Qualifiers> ::= TypeQualifier <Type Qualifiers Continued>
	Rule_TypeQualifiers_TypeQualifier,
	// 75. <Type Qualifiers> ::= 
	Rule_TypeQualifiers,
	// 76. <Type Qualifiers Continued> ::= TypeQualifier <Type Qualifiers Continued>
	Rule_TypeQualifiersContinued_TypeQualifier,
	// 77. <Type Qualifiers Continued> ::= 
	Rule_TypeQualifiersContinued,
	// 78. <Optional Optim Qualifier> ::= OptimQualifier
	Rule_OptionalOptimQualifier_OptimQualifier,
	// 79. <Optional Optim Qualifier> ::= 
	Rule_OptionalOptimQualifier,
	// 80. <Optional Visibility Qualifier> ::= VisibilityQualifier
	Rule_OptionalVisibilityQualifier_VisibilityQualifier,
	// 81. <Optional Visibility Qualifier> ::= 
	Rule_OptionalVisibilityQualifier,
	// 82. <Argument List> ::= <Expression> <Argument List Continued>
	Rule_ArgumentList,
	// 83. <Argument List> ::= 
	Rule_ArgumentList2,
	// 84. <Argument List Continued> ::= ',' <Expression>
	Rule_ArgumentListContinued_Comma,
	// 85. <Argument List Continued> ::= 
	Rule_ArgumentListContinued,
	// 86. <In Block> ::= in <Expression>
	Rule_InBlock_in,
	// 87. <In Block> ::= 
	Rule_InBlock,
	// 88. <Out Block> ::= out <Expression>
	Rule_OutBlock_out,
	// 89. <Out Block> ::= 
	Rule_OutBlock,
	// 90. <Optional Type Parameters> ::= '<' <Type Parameters>
	Rule_OptionalTypeParameters_Lt,
	// 91. <Optional Type Parameters> ::= 
	Rule_OptionalTypeParameters,
	// 92. <Type Parameters> ::= Identifier <Type Parameters Continued> '>'
	Rule_TypeParameters_Identifier_Gt,
	// 93. <Type Parameters> ::= Identifier ':=' <Expression> <Type Parameters Continued> '>'
	Rule_TypeParameters_Identifier_ColonEq_Gt,
	// 94. <Type Parameters Continued> ::= ',' Identifier <Type Parameters Continued>
	Rule_TypeParametersContinued_Comma_Identifier,
	// 95. <Type Parameters Continued> ::= ',' Identifier ':=' <Expression> <Type Parameters Continued>
	Rule_TypeParametersContinued_Comma_Identifier_ColonEq,
	// 96. <Type Parameters Continued> ::= 
	Rule_TypeParametersContinued,
	// 97. <Type Arguments> ::= <Expression> <Type Arguments Continued> '>'
	Rule_TypeArguments_Gt,
	// 98. <Type Arguments Continued> ::= ',' <Expression> <Type Parameters Continued>
	Rule_TypeArgumentsContinued_Comma,
	// 99. <Type Arguments Continued> ::= 
	Rule_TypeArgumentsContinued,
	// 100. <Expression> ::= <Possibly Parallel Exp> <Expression List>
	Rule_Expression,
	// 101. <Expression List> ::= ';' <Expression>
	Rule_ExpressionList_Semi,
	// 102. <Expression List> ::= 
	Rule_ExpressionList,
	// 103. <Possibly Parallel Exp> ::= <SingleThread Exp>
	Rule_PossiblyParallelExp,
	// 104. <Possibly Parallel Exp> ::= '&' <SingleThread Exp>
	Rule_PossiblyParallelExp_Amp,
	// 105. <SingleThread Exp> ::= <Assignment Exp>
	Rule_SingleThreadExp,
	// 106. <Assignment Exp> ::= <Simple Exp> <Optional Typing> <Optional Assignment>
	Rule_AssignmentExp,
	// 107. <Simple Exp> ::= <Binary Exp>
	Rule_SimpleExp,
	// 108. <Simple Exp> ::= return <SingleThread Exp>
	Rule_SimpleExp_return,
	// 109. <Simple Exp> ::= typeof <SingleThread Exp>
	Rule_SimpleExp_typeof,
	// 110. <Simple Exp> ::= break
	Rule_SimpleExp_break,
	// 111. <Simple Exp> ::= continue
	Rule_SimpleExp_continue,
	// 112. <Simple Exp> ::= <Attribute Declaration>
	Rule_SimpleExp2,
	// 113. <Simple Exp> ::= if <Expression> then <Expression> <Else Expression>
	Rule_SimpleExp_if_then,
	// 114. <Simple Exp> ::= while <Expression> do <Expression>
	Rule_SimpleExp_while_do,
	// 115. <Simple Exp> ::= for Identifier in <Expression> do <Expression>
	Rule_SimpleExp_for_Identifier_in_do,
	// 116. <Simple Exp> ::= for Identifier in <Expression> order ':' <Expression> packedby ':' <Expression> do <Expression>
	Rule_SimpleExp_for_Identifier_in_order_Colon_packedby_Colon_do,
	// 117. <Simple Exp> ::= for Identifier in <Expression> order do <Expression>
	Rule_SimpleExp_for_Identifier_in_order_do,
	// 118. <Simple Exp> ::= timeout <Expression> do <Expression>
	Rule_SimpleExp_timeout_do,
	// 119. <Simple Exp> ::= timeout <Expression> do <Expression> else <Expression>
	Rule_SimpleExp_timeout_do_else,
	// 120. <Simple Exp> ::= '{' <Expression> '}'
	Rule_SimpleExp_LBrace_RBrace,
	// 121. <Else Expression> ::= else <Expression>
	Rule_ElseExpression_else,
	// 122. <Else Expression> ::= 
	Rule_ElseExpression,
	// 123. <Binary Exp> ::= <SingleThread Exp> '|' <Xor Exp>
	Rule_BinaryExp_Pipe,
	// 124. <Binary Exp> ::= <Xor Exp>
	Rule_BinaryExp,
	// 125. <Xor Exp> ::= <Xor Exp> xor <Or Exp>
	Rule_XorExp_xor,
	// 126. <Xor Exp> ::= <Or Exp>
	Rule_XorExp,
	// 127. <Or Exp> ::= <Or Exp> or <And Exp>
	Rule_OrExp_or,
	// 128. <Or Exp> ::= <And Exp>
	Rule_OrExp,
	// 129. <And Exp> ::= <And Exp> and <Compare Exp>
	Rule_AndExp_and,
	// 130. <And Exp> ::= <Equal Exp>
	Rule_AndExp,
	// 131. <Equal Exp> ::= <Equal Exp> '=' <Compare Exp>
	Rule_EqualExp_Eq,
	// 132. <Equal Exp> ::= <Equal Exp> '!=' <Compare Exp>
	Rule_EqualExp_ExclamEq,
	// 133. <Equal Exp> ::= <Compare Exp>
	Rule_EqualExp,
	// 134. <Compare Exp> ::= <Compare Exp> '>' <Regexp Exp>
	Rule_CompareExp_Gt,
	// 135. <Compare Exp> ::= <Compare Exp> '<=' <Regexp Exp>
	Rule_CompareExp_LtEq,
	// 136. <Compare Exp> ::= <Compare Exp> '>=' <Regexp Exp>
	Rule_CompareExp_GtEq,
	// 137. <Compare Exp> ::= <Inferior Exp>
	Rule_CompareExp,
	// 138. <Compare Exp> ::= <Regexp Exp>
	Rule_CompareExp2,
	// 139. <Inferior Exp> ::= <Compare Exp> '<' <Regexp Exp>
	Rule_InferiorExp_Lt,
	// 140. <Regexp Exp> ::= <Regexp Exp> '~' <Shift Exp>
	Rule_RegexpExp_Tilde,
	// 141. <Regexp Exp> ::= <Shift Exp>
	Rule_RegexpExp,
	// 142. <Shift Exp> ::= <Shift Exp> '<<' <Add Exp>
	Rule_ShiftExp_LtLt,
	// 143. <Shift Exp> ::= <Shift Exp> '>>' <Add Exp>
	Rule_ShiftExp_GtGt,
	// 144. <Shift Exp> ::= <Add Exp>
	Rule_ShiftExp,
	// 145. <Add Exp> ::= <Add Exp> '+' <Mult Exp>
	Rule_AddExp_Plus,
	// 146. <Add Exp> ::= <Add Exp> '-' <Mult Exp>
	Rule_AddExp_Minus,
	// 147. <Add Exp> ::= <Mult Exp>
	Rule_AddExp,
	// 148. <Mult Exp> ::= <Mult Exp> '*' <Power Exp>
	Rule_MultExp_Times,
	// 149. <Mult Exp> ::= <Mult Exp> '/' <Power Exp>
	Rule_MultExp_Div,
	// 150. <Mult Exp> ::= <Power Exp>
	Rule_MultExp,
	// 151. <Power Exp> ::= <Power Exp> '^' <Negate Exp>
	Rule_PowerExp_Caret,
	// 152. <Power Exp> ::= <Negate Exp>
	Rule_PowerExp,
	// 153. <Negate Exp> ::= '-' <Value>
	Rule_NegateExp_Minus,
	// 154. <Negate Exp> ::= -- <Value>
	Rule_NegateExp_MinusMinus,
	// 155. <Negate Exp> ::= '++' <Value>
	Rule_NegateExp_PlusPlus,
	// 156. <Negate Exp> ::= <Value> --
	Rule_NegateExp_MinusMinus2,
	// 157. <Negate Exp> ::= <Value> '++'
	Rule_NegateExp_PlusPlus2,
	// 158. <Negate Exp> ::= <Value>
	Rule_NegateExp,
	// 159. <Value> ::= <Literal> <Subscript>
	Rule_Value,
	// 160. <Value> ::= '(' <SingleThread Exp> ')' <Subscript>
	Rule_Value_LParan_RParan,
	// 161. <Value> ::= Identifier <Subscript>
	Rule_Value_Identifier,
	// 162. <Subscript> ::= 
	Rule_Subscript,
	// 163. <Subscript> ::= '.' <Value>
	Rule_Subscript_Dot,
	// 164. <Subscript> ::= '(' <Argument List> ')'
	Rule_Subscript_LParan_RParan 
};

///// Rule subroutine template


template<class NodeT = Nany::Ast::Node>
static NodeT* ParseChild(struct TokenStruct* parent, unsigned int index)
{
	// Make sure the child index is not out of bounds
	assert(index < (unsigned int)Grammar.RuleArray[parent->ReductionRule].SymbolsCount && "ParseChild: index out of bounds !");

	struct TokenStruct* child = parent->Tokens[index];

	// Make sure the child is a rule
	assert(child->ReductionRule >= 0 && "ParseChild must be called on a rule !");

	// Call the rule's subroutine via the RuleJumpTable and return the node
	Nany::Ast::Node* genericNode = RuleJumpTable[child->ReductionRule](child);

	// Cast into the specific wanted node type
	NodeT* specificNode = dynamic_cast<NodeT*>(genericNode);
	assert(specificNode == genericNode && "ParseChild : Invalid dynamic cast !");

	return specificNode;
}


static const wchar_t* GetChildSymbol(struct TokenStruct* parent, unsigned int index)
{
	// Make sure the child index is not out of bounds
	assert(index < (unsigned int)Grammar.RuleArray[parent->ReductionRule].SymbolsCount && "GetChildSymbol: index out of bounds !");

	struct TokenStruct* child = parent->Tokens[index];

	// Make sure the child is a symbol
	assert(child->ReductionRule < 0 && "GetChildSymbol must be called on a symbol !");

	return child->Data;
}




///// Main



// Load input file from disk into memory.
static wchar_t* LoadInputFile(const char *fileName)
{
	// Sanity check.
	if (!fileName || !*fileName)
		return nullptr;

	// Open the file.
	FILE* inFile = fopen(fileName, "rb");
	if (!inFile)
	{
		std::cerr << "Could not open input file: " << fileName << std::endl;
		return nullptr;
	}

	// Get the size of the file.
	struct stat statbuf;
	if (fstat(fileno(inFile), &statbuf) != 0)
	{
		std::cerr << "Could not stat() the input file: " << fileName << std::endl;
		fclose(inFile);
		return NULL;
	}

	// Allocate memory for the input.
	char* buf1 = new char[statbuf.st_size + 1];
	wchar_t* buf2 = new wchar_t[sizeof(wchar_t) * (statbuf.st_size + 1)];
	if (!buf1 || !buf2)
	{
		std::cerr << "Not enough memory to load the file: " << fileName << std::endl;
		fclose(inFile);
		if (buf1 != NULL)
			delete buf1;
		if (buf2 != NULL)
			delete buf2;
		return NULL;
	}

	// Load the file into memory.
	size_t bytesRead = fread(buf1, 1, statbuf.st_size, inFile);
	buf1[bytesRead] = '\0';

	// Close the file.
	fclose(inFile);

	// Exit if there was an error while reading the file.
	if (bytesRead != (size_t)statbuf.st_size)
	{
		std::cerr << "Error while reading input file: " << fileName << std::endl;
		delete buf1;
		delete buf2;
		return nullptr;
	}

	// Convert from ASCII to Unicode.
	for (unsigned long i = 0; i <= bytesRead; i++)
		buf2[i] = buf1[i];
	delete buf1;

	return buf2;
}



static void ShowErrorMessage(struct TokenStruct* token, int result)
{
	switch (result)
	{
		case PARSELEXICALERROR:
			std::cerr << "Lexical error";
			break;
		case PARSECOMMENTERROR:
			std::cerr << "Comment error";
			break;
		case PARSETOKENERROR:
			std::cerr << "Tokenizer error";
			break;
		case PARSESYNTAXERROR:
			std::cerr << "Syntax error";
			break;
		case PARSEMEMORYERROR:
			std::cerr << "Out of memory";
			break;
	}
	if (token != NULL)
		std::cerr << " at line " << token->Line << " column " << token->Column;
	std::cerr << "." << std::endl;

	if (result == PARSELEXICALERROR)
	{
		if (token->Data != NULL)
		{
			wchar_t s1[BUFSIZ];
			ReadableString(token->Data, s1, BUFSIZ);
			std::cerr << "The grammar does not specify what to do with '" << s1 << "'." << std::endl;
		}
		else
		{
			std::cerr << "The grammar does not specify what to do." << std::endl;
		}
	}
	if (result == PARSETOKENERROR)
	{
		std::cerr << "The tokenizer returned a non-terminal." << std::endl;
	}
	if (result == PARSECOMMENTERROR)
	{
		std::cerr << "The comment has no end, it was started but not finished." << std::endl;
	}
	if (result == PARSESYNTAXERROR)
	{
		if (token->Data != NULL)
		{
			wchar_t s1[BUFSIZ];
			ReadableString(token->Data, s1, BUFSIZ);
			std::cerr << "Encountered '" << s1 << "', but expected ";
		}
		else
		{
			std::cerr << "Expected ";
		}
		for (int i = 0; i < Grammar.LalrArray[token->Symbol].ActionCount; i++)
		{
			int symbol = Grammar.LalrArray[token->Symbol].Actions[i].Entry;
			if (Grammar.SymbolArray[symbol].Kind == SYMBOLTERMINAL)
			{
				if (i > 0)
				{
					std::cerr << ", ";
					if (i >= Grammar.LalrArray[token->Symbol].ActionCount - 2)
						std::cerr << "or ";
				}
				std::cerr << '\'' << Grammar.SymbolArray[symbol].Name << '\'';
			}
		}
		std::cerr << "." << std::endl;
	}
}



Nany::Ast::Node* parseFile(const char* filePath)
{
	Nany::Ast::Node* tree = nullptr;

	// Load the inputfile into memory.
	wchar_t* inputBuf = LoadInputFile(filePath);
	if (!inputBuf)
	{
		std::cerr << "\"" << filePath << "\" could not be opened." << std::endl;
		return tree;
	}


	// Run the Parser.
	struct TokenStruct* token;
	int parseResult = Parse(inputBuf, wcslen(inputBuf), TRIMREDUCTIONS, &token);

	// Interpret the results.
	if (parseResult != PARSEACCEPT)
	{
		ShowErrorMessage(token, parseResult);
	}
	else
	{
		// Start execution by calling the subroutine of the first Token on
		// the TokenStack. It's the "Start Symbol" that is defined in the
		// grammar.
		tree = RuleJumpTable[token->ReductionRule](token);
	}

	// Cleanup.
	DeleteTokens(token);
	delete inputBuf;
	return tree;
}
