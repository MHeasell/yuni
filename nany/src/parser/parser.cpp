/*

  This file was generated by the "C - Kessels engine template.c" template.

*/


#include <cstdio>
#include <cstdlib>
#include <wchar.h>                  /* wchar_t */
#include <sys/stat.h>
#include <cassert>
#include <iostream>

extern "C"
{
#include "engine.h"                 /* The Kessels engine. */
#include "grammar.h"                /* Generated by GOLD. */
}
#include "parser.h"
#include "yuni/yuni.h"
#include "yuni/core/string.h"
#include "../ast/all.h"


#define TRIMREDUCTIONS 0            /* 0=off, 1=on */




/* Struct for transporting data between rules. Add whatever you need.
   Note: you could also use global variables to store stuff, but using
   a struct like this makes the interpreter thread-safe. */
struct ContextStruct
{
	wchar_t *ReturnValue;             /* In this template all rules return a string. */
	int Indent;                       /* For printing debug messages. */
};




/***** Helper subroutines ***************************************************/




/* Make a readable copy of a string. All characters outside 32...127 are
   displayed as a HEX number in square brackets, for example "[0A]". */
static void ReadableString(wchar_t *Input, wchar_t *Output, long Width)
{
	char s1[BUFSIZ];
	long i1;
	long i2;

	/* Sanity check. */
	if ((Output == NULL) || (Width < 1))
		return;
	Output[0] = 0;
	if (Input == NULL)
		return;

	i1 = 0;
	i2 = 0;
	while ((i2 < Width - 1) && (Input[i1] != 0))
	{
		if ((Input[i1] >= 32) && (Input[i1] <= 127))
		{
			Output[i2++] = Input[i1];
		}
		else
		{
			if (Width - i2 > 4)
			{
				sprintf(s1,"%02X",Input[i1]);
				Output[i2++] = '[';
				Output[i2++] = s1[0];
				Output[i2++] = s1[1];
				Output[i2++] = ']';
			}
		}
		i1++;
	}
	Output[i2] = 0;
}




// Forward declaration of the template for rule management
static Nany::Ast::Node* RuleTemplate(struct TokenStruct *Token, struct ContextStruct *Context);
static Nany::Ast::Node* ParseChild(struct TokenStruct* token, struct ContextStruct* context, unsigned int index);


/***** Rule subroutines *****************************************************/




/* <Program> ::= <Unit Declaration> <Dependencies> <Implementation Block> */
Nany::Ast::Node* Rule_Program(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Unit Declaration> ::= <Optional Visibility Qualifier> unit Identifier ';' */
Nany::Ast::Node* Rule_UnitDeclaration_unit_Identifier_Semi(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Unit Declaration> ::= program Identifier ';' */
Nany::Ast::Node* Rule_UnitDeclaration_program_Identifier_Semi(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Dependencies> ::= <Dependency> <Dependencies> */
Nany::Ast::Node* Rule_Dependencies(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Dependencies> ::=  */
Nany::Ast::Node* Rule_Dependencies2(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Dependency> ::= uses Identifier <Dependency Continued> ';' */
Nany::Ast::Node* Rule_Dependency_uses_Identifier_Semi(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Dependency Continued> ::= '.' Identifier <Dependency Continued> */
Nany::Ast::Node* Rule_DependencyContinued_Dot_Identifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Dependency Continued> ::=  */
Nany::Ast::Node* Rule_DependencyContinued(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Implementation Block> ::= <Function Declaration> <Implementation Block> */
Nany::Ast::Node* Rule_ImplementationBlock(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Implementation Block> ::= <Optional Visibility Qualifier> <Class Declaration> <Implementation Block> */
Nany::Ast::Node* Rule_ImplementationBlock2(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Implementation Block> ::= <Optional Visibility Qualifier> <Workflow Declaration> <Implementation Block> */
Nany::Ast::Node* Rule_ImplementationBlock3(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Implementation Block> ::= <Optional Visibility Qualifier> <Enum Declaration> <Implementation Block> */
Nany::Ast::Node* Rule_ImplementationBlock4(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Implementation Block> ::=  */
Nany::Ast::Node* Rule_ImplementationBlock5(struct TokenStruct*, struct ContextStruct*)
{
	return nullptr;
};




/* <Literal> ::= BooleanLiteral */
Nany::Ast::Node* Rule_Literal_BooleanLiteral(struct TokenStruct *Token, struct ContextStruct *Context)
{
	Nany::Ast::Node* child0 = ParseChild(Token, Context, 0);
	assert(nullptr == child0 && "Child must be a symbol !");
	return new Nany::Ast::LiteralNode<bool>(L't' == Context->ReturnValue[0]);
};




/* <Literal> ::= DecLiteral */
Nany::Ast::Node* Rule_Literal_DecLiteral(struct TokenStruct *Token, struct ContextStruct *Context)
{
	Nany::Ast::Node* child0 = ParseChild(Token, Context, 0);
	assert(nullptr == child0 && "Child must be a symbol !");
	assert(Context->ReturnValue && "Child must be a symbol !");

	Yuni::String data(Context->ReturnValue);
	bool isUnsigned = data[data.size() - 1] == 'u' || (data.size() > 1 && data[data.size() - 2] == 'u')
		|| data[data.size() - 1] == 'U' || (data.size() > 1 && data[data.size() - 2] == 'U');
	if (isUnsigned)
		return new Nany::Ast::LiteralNode<unsigned int>(data.to<unsigned int>());
	else
		return new Nany::Ast::LiteralNode<int>(data.to<int>());
};




/* <Literal> ::= HexLiteral */
Nany::Ast::Node* Rule_Literal_HexLiteral(struct TokenStruct *Token, struct ContextStruct *Context)
{
	Nany::Ast::Node* child0 = ParseChild(Token, Context, 0);
	assert(nullptr == child0 && "Child must be a symbol !");
	assert(Context->ReturnValue && "Symbol must not be empty !");

	Yuni::String data(Context->ReturnValue);
	bool isUnsigned = data[data.size() - 1] == 'u' || (data.size() > 1 && data[data.size() - 2] == 'u')
		|| data[data.size() - 1] == 'U' || (data.size() > 1 && data[data.size() - 2] == 'U');
	if (isUnsigned)
		return new Nany::Ast::LiteralNode<unsigned int>(data.to<unsigned int>());
	else
		return new Nany::Ast::LiteralNode<int>(data.to<int>());
};




/* <Literal> ::= RealLiteral */
Nany::Ast::Node* Rule_Literal_RealLiteral(struct TokenStruct *Token, struct ContextStruct *Context)
{
	Nany::Ast::Node* child0 = ParseChild(Token, Context, 0);
	assert(nullptr == child0 && "Child must be a symbol !");
	assert(Context->ReturnValue && "Symbol must not be empty !");

	Yuni::String data(Context->ReturnValue);
	return new Nany::Ast::LiteralNode<int>(data.to<float>());
};




/* <Literal> ::= TimeLiteral */
Nany::Ast::Node* Rule_Literal_TimeLiteral(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Literal> ::= CharLiteral */
Nany::Ast::Node* Rule_Literal_CharLiteral(struct TokenStruct *Token, struct ContextStruct *Context)
{
	Nany::Ast::Node* child0 = ParseChild(Token, Context, 0);
	assert(nullptr == child0 && "Child must be a symbol !");
	assert(Context->ReturnValue && "Symbol must not be empty !");

	return new Nany::Ast::LiteralNode<char>(Context->ReturnValue[0]);
};




/* <Literal> ::= StringLiteral */
Nany::Ast::Node* Rule_Literal_StringLiteral(struct TokenStruct *Token, struct ContextStruct *Context)
{
	Nany::Ast::Node* child0 = ParseChild(Token, Context, 0);
	assert(nullptr == child0 && "Child must be a symbol !");
	assert(Context->ReturnValue && "Symbol must not be empty !");

	Yuni::String data(Context->ReturnValue);
	return new Nany::Ast::LiteralNode<const char*>(data.to<const char*>());
};




/* <Literal> ::= BuiltInType */
Nany::Ast::Node* Rule_Literal_BuiltInType(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Literal> ::= nil */
Nany::Ast::Node* Rule_Literal_nil(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Literal> ::= self */
Nany::Ast::Node* Rule_Literal_self(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Class Declaration> ::= class Identifier <Optional Type Parameters> <In Block> <Out Block> '{' <Class Content> '}' */
Nany::Ast::Node* Rule_ClassDeclaration_class_Identifier_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Class Content> ::= VisibilityQualifier <Class Content> */
Nany::Ast::Node* Rule_ClassContent_VisibilityQualifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Class Content> ::= <Method Declaration> <Class Content> */
Nany::Ast::Node* Rule_ClassContent(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Class Content> ::= <Attribute Declaration> ';' <Class Content> */
Nany::Ast::Node* Rule_ClassContent_Semi(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Class Content> ::= <Property Declaration> ';' <Class Content> */
Nany::Ast::Node* Rule_ClassContent_Semi2(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Class Content> ::= <Class Declaration> <Class Content> */
Nany::Ast::Node* Rule_ClassContent2(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Class Content> ::=  */
Nany::Ast::Node* Rule_ClassContent3(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Property Declaration> ::= property Identifier <Optional Typing> <Optional Assignment> <Property Callbacks> */
Nany::Ast::Node* Rule_PropertyDeclaration_property_Identifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Property Callbacks> ::= read <SingleThread Exp> <Property Callbacks> */
Nany::Ast::Node* Rule_PropertyCallbacks_read(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Property Callbacks> ::= write <SingleThread Exp> <Property Callbacks> */
Nany::Ast::Node* Rule_PropertyCallbacks_write(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Property Callbacks> ::=  */
Nany::Ast::Node* Rule_PropertyCallbacks(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Attribute Declaration> ::= attribute Identifier <Optional Typing> <Optional Assignment> */
Nany::Ast::Node* Rule_AttributeDeclaration_attribute_Identifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Attribute Declaration> ::= ConstQualifier attribute Identifier <Optional Typing> <Optional Assignment> */
Nany::Ast::Node* Rule_AttributeDeclaration_ConstQualifier_attribute_Identifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Optional Assignment> ::= ':=' <Expression> */
Nany::Ast::Node* Rule_OptionalAssignment_ColonEq(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Optional Assignment> ::=  */
Nany::Ast::Node* Rule_OptionalAssignment(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Optional Typing> ::= ':' <Type Qualifiers> <SingleThread Exp> */
Nany::Ast::Node* Rule_OptionalTyping_Colon(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Optional Typing> ::=  */
Nany::Ast::Node* Rule_OptionalTyping(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Workflow Declaration> ::= workflow Identifier '{' <Workflow Content> '}' */
Nany::Ast::Node* Rule_WorkflowDeclaration_workflow_Identifier_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Workflow Content> ::= <State Block> <Transition Block> */
Nany::Ast::Node* Rule_WorkflowContent(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <State Block> ::= states <Workflow States> */
Nany::Ast::Node* Rule_StateBlock_states(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <State Block> ::=  */
Nany::Ast::Node* Rule_StateBlock(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Workflow States> ::= default Identifier ';' <Workflow States> */
Nany::Ast::Node* Rule_WorkflowStates_default_Identifier_Semi(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Workflow States> ::= state Identifier ';' <Workflow States> */
Nany::Ast::Node* Rule_WorkflowStates_state_Identifier_Semi(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Workflow States> ::=  */
Nany::Ast::Node* Rule_WorkflowStates(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Transition Block> ::= transitions <Workflow Transitions> */
Nany::Ast::Node* Rule_TransitionBlock_transitions(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Transition Block> ::=  */
Nany::Ast::Node* Rule_TransitionBlock(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Workflow Transitions> ::= default allow ';' <Workflow Transitions> */
Nany::Ast::Node* Rule_WorkflowTransitions_default_allow_Semi(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Workflow Transitions> ::= default forbid ';' <Workflow Transitions> */
Nany::Ast::Node* Rule_WorkflowTransitions_default_forbid_Semi(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Workflow Transitions> ::= allow <Workflow Permissions> '=>' <Workflow Permissions> ';' <Workflow Transitions> */
Nany::Ast::Node* Rule_WorkflowTransitions_allow_EqGt_Semi(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Workflow Transitions> ::= forbid <Workflow Permissions> '=>' <Workflow Permissions> ';' <Workflow Transitions> */
Nany::Ast::Node* Rule_WorkflowTransitions_forbid_EqGt_Semi(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Workflow Transitions> ::=  */
Nany::Ast::Node* Rule_WorkflowTransitions(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Workflow Permission> ::= '*' */
Nany::Ast::Node* Rule_WorkflowPermission_Times(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Workflow Permission> ::= Identifier */
Nany::Ast::Node* Rule_WorkflowPermission_Identifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Workflow Permission> ::= '+' Identifier */
Nany::Ast::Node* Rule_WorkflowPermission_Plus_Identifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Workflow Permission> ::= '-' Identifier */
Nany::Ast::Node* Rule_WorkflowPermission_Minus_Identifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Workflow Permissions> ::= <Workflow Permission> ',' <Workflow Permissions> */
Nany::Ast::Node* Rule_WorkflowPermissions_Comma(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Workflow Permissions> ::= <Workflow Permission> */
Nany::Ast::Node* Rule_WorkflowPermissions(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Enum Declaration> ::= enum Identifier '{' <Enum Content> '}' */
Nany::Ast::Node* Rule_EnumDeclaration_enum_Identifier_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Enum Content> ::= Identifier ',' <Enum Content> */
Nany::Ast::Node* Rule_EnumContent_Identifier_Comma(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Enum Content> ::= Identifier */
Nany::Ast::Node* Rule_EnumContent_Identifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Enum Content> ::=  */
Nany::Ast::Node* Rule_EnumContent(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Function Declaration> ::= <Optional Optim Qualifier> function Identifier <Optional Type Parameters> <Optional Parameters> <Return Type Declaration> <In Block> <Out Block> '{' <Expression> '}' */
Nany::Ast::Node* Rule_FunctionDeclaration_function_Identifier_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Method Declaration> ::= <Optional Optim Qualifier> method Identifier <Optional Type Parameters> <Optional Parameters> <Return Type Declaration> <In Block> <Out Block> '{' <Expression> '}' */
Nany::Ast::Node* Rule_MethodDeclaration_method_Identifier_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Return Type Declaration> ::= ':' <Expression> */
Nany::Ast::Node* Rule_ReturnTypeDeclaration_Colon(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Return Type Declaration> ::=  */
Nany::Ast::Node* Rule_ReturnTypeDeclaration(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Optional Parameters> ::= '(' <Parameter List> ')' */
Nany::Ast::Node* Rule_OptionalParameters_LParan_RParan(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Optional Parameters> ::=  */
Nany::Ast::Node* Rule_OptionalParameters(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Parameter List> ::= Identifier <Optional Typing> <Optional Assignment> <Parameter List Continued> */
Nany::Ast::Node* Rule_ParameterList_Identifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Parameter List> ::=  */
Nany::Ast::Node* Rule_ParameterList(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Parameter List Continued> ::= ',' <Parameter List> */
Nany::Ast::Node* Rule_ParameterListContinued_Comma(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Parameter List Continued> ::=  */
Nany::Ast::Node* Rule_ParameterListContinued(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Type Qualifiers> ::= TypeQualifier <Type Qualifiers Continued> */
Nany::Ast::Node* Rule_TypeQualifiers_TypeQualifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Type Qualifiers> ::=  */
Nany::Ast::Node* Rule_TypeQualifiers(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Type Qualifiers Continued> ::= TypeQualifier <Type Qualifiers Continued> */
Nany::Ast::Node* Rule_TypeQualifiersContinued_TypeQualifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Type Qualifiers Continued> ::=  */
Nany::Ast::Node* Rule_TypeQualifiersContinued(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Optional Optim Qualifier> ::= OptimQualifier */
Nany::Ast::Node* Rule_OptionalOptimQualifier_OptimQualifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Optional Optim Qualifier> ::=  */
Nany::Ast::Node* Rule_OptionalOptimQualifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Optional Visibility Qualifier> ::= VisibilityQualifier */
Nany::Ast::Node* Rule_OptionalVisibilityQualifier_VisibilityQualifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Optional Visibility Qualifier> ::=  */
Nany::Ast::Node* Rule_OptionalVisibilityQualifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Argument List> ::= <Expression> <Argument List Continued> */
Nany::Ast::Node* Rule_ArgumentList(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Argument List> ::=  */
Nany::Ast::Node* Rule_ArgumentList2(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Argument List Continued> ::= ',' <Expression> */
Nany::Ast::Node* Rule_ArgumentListContinued_Comma(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Argument List Continued> ::=  */
Nany::Ast::Node* Rule_ArgumentListContinued(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <In Block> ::= in <Expression> */
Nany::Ast::Node* Rule_InBlock_in(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <In Block> ::=  */
Nany::Ast::Node* Rule_InBlock(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Out Block> ::= out <Expression> */
Nany::Ast::Node* Rule_OutBlock_out(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Out Block> ::=  */
Nany::Ast::Node* Rule_OutBlock(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Optional Type Parameters> ::= '<' <Type Parameters> */
Nany::Ast::Node* Rule_OptionalTypeParameters_Lt(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Optional Type Parameters> ::=  */
Nany::Ast::Node* Rule_OptionalTypeParameters(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Type Parameters> ::= Identifier <Type Parameters Continued> '>' */
Nany::Ast::Node* Rule_TypeParameters_Identifier_Gt(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Type Parameters> ::= Identifier ':=' <Expression> <Type Parameters Continued> '>' */
Nany::Ast::Node* Rule_TypeParameters_Identifier_ColonEq_Gt(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Type Parameters Continued> ::= ',' Identifier <Type Parameters Continued> */
Nany::Ast::Node* Rule_TypeParametersContinued_Comma_Identifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Type Parameters Continued> ::= ',' Identifier ':=' <Expression> <Type Parameters Continued> */
Nany::Ast::Node* Rule_TypeParametersContinued_Comma_Identifier_ColonEq(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Type Parameters Continued> ::=  */
Nany::Ast::Node* Rule_TypeParametersContinued(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Type Arguments> ::= <Expression> <Type Arguments Continued> '>' */
Nany::Ast::Node* Rule_TypeArguments_Gt(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Type Arguments Continued> ::= ',' <Expression> <Type Parameters Continued> */
Nany::Ast::Node* Rule_TypeArgumentsContinued_Comma(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Type Arguments Continued> ::=  */
Nany::Ast::Node* Rule_TypeArgumentsContinued(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Expression> ::= <Possibly Parallel Exp> <Expression List> */
Nany::Ast::Node* Rule_Expression(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Expression List> ::= ';' <Expression> */
Nany::Ast::Node* Rule_ExpressionList_Semi(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Expression List> ::=  */
Nany::Ast::Node* Rule_ExpressionList(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Possibly Parallel Exp> ::= <SingleThread Exp> */
Nany::Ast::Node* Rule_PossiblyParallelExp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Possibly Parallel Exp> ::= '&' <SingleThread Exp> */
Nany::Ast::Node* Rule_PossiblyParallelExp_Amp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <SingleThread Exp> ::= <Assignment Exp> */
Nany::Ast::Node* Rule_SingleThreadExp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Assignment Exp> ::= <Simple Exp> <Optional Typing> <Optional Assignment> */
Nany::Ast::Node* Rule_AssignmentExp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Simple Exp> ::= <Binary Exp> */
Nany::Ast::Node* Rule_SimpleExp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Simple Exp> ::= return <SingleThread Exp> */
Nany::Ast::Node* Rule_SimpleExp_return(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Simple Exp> ::= typeof <SingleThread Exp> */
Nany::Ast::Node* Rule_SimpleExp_typeof(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Simple Exp> ::= break */
Nany::Ast::Node* Rule_SimpleExp_break(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Simple Exp> ::= continue */
Nany::Ast::Node* Rule_SimpleExp_continue(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Simple Exp> ::= <Attribute Declaration> */
Nany::Ast::Node* Rule_SimpleExp2(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Simple Exp> ::= if <Expression> then <Expression> <Else Expression> */
Nany::Ast::Node* Rule_SimpleExp_if_then(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Simple Exp> ::= while <Expression> do <Expression> */
Nany::Ast::Node* Rule_SimpleExp_while_do(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Simple Exp> ::= for Identifier ':=' <Expression> until <Expression> do <Expression> */
Nany::Ast::Node* Rule_SimpleExp_for_Identifier_ColonEq_until_do(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Simple Exp> ::= for Identifier ':=' <Expression> until <Expression> step <Expression> do <Expression> */
Nany::Ast::Node* Rule_SimpleExp_for_Identifier_ColonEq_until_step_do(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Simple Exp> ::= foreach Identifier in <Expression> do <Expression> */
Nany::Ast::Node* Rule_SimpleExp_foreach_Identifier_in_do(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Simple Exp> ::= foreach Identifier in <Expression> order do <Expression> */
Nany::Ast::Node* Rule_SimpleExp_foreach_Identifier_in_order_do(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Simple Exp> ::= timeout <Expression> do <Expression> */
Nany::Ast::Node* Rule_SimpleExp_timeout_do(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Simple Exp> ::= timeout <Expression> do <Expression> else <Expression> */
Nany::Ast::Node* Rule_SimpleExp_timeout_do_else(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Simple Exp> ::= '{' <Expression> '}' */
Nany::Ast::Node* Rule_SimpleExp_LBrace_RBrace(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Else Expression> ::= else <Expression> */
Nany::Ast::Node* Rule_ElseExpression_else(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Else Expression> ::=  */
Nany::Ast::Node* Rule_ElseExpression(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Binary Exp> ::= <SingleThread Exp> '|' <Xor Exp> */
Nany::Ast::Node* Rule_BinaryExp_Pipe(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Binary Exp> ::= <Xor Exp> */
Nany::Ast::Node* Rule_BinaryExp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Xor Exp> ::= <Xor Exp> xor <Or Exp> */
Nany::Ast::Node* Rule_XorExp_xor(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Xor Exp> ::= <Or Exp> */
Nany::Ast::Node* Rule_XorExp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Or Exp> ::= <Or Exp> or <And Exp> */
Nany::Ast::Node* Rule_OrExp_or(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Or Exp> ::= <And Exp> */
Nany::Ast::Node* Rule_OrExp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <And Exp> ::= <And Exp> and <Compare Exp> */
Nany::Ast::Node* Rule_AndExp_and(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <And Exp> ::= <Equal Exp> */
Nany::Ast::Node* Rule_AndExp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Equal Exp> ::= <Equal Exp> '=' <Compare Exp> */
Nany::Ast::Node* Rule_EqualExp_Eq(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Equal Exp> ::= <Equal Exp> '!=' <Compare Exp> */
Nany::Ast::Node* Rule_EqualExp_ExclamEq(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Equal Exp> ::= <Compare Exp> */
Nany::Ast::Node* Rule_EqualExp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Compare Exp> ::= <Compare Exp> '>' <Regexp Exp> */
Nany::Ast::Node* Rule_CompareExp_Gt(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Compare Exp> ::= <Compare Exp> '<=' <Regexp Exp> */
Nany::Ast::Node* Rule_CompareExp_LtEq(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Compare Exp> ::= <Compare Exp> '>=' <Regexp Exp> */
Nany::Ast::Node* Rule_CompareExp_GtEq(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Compare Exp> ::= <Inferior Exp> */
Nany::Ast::Node* Rule_CompareExp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Compare Exp> ::= <Regexp Exp> */
Nany::Ast::Node* Rule_CompareExp2(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Inferior Exp> ::= <Compare Exp> '<' <Regexp Exp> */
Nany::Ast::Node* Rule_InferiorExp_Lt(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Regexp Exp> ::= <Regexp Exp> '~' <Shift Exp> */
Nany::Ast::Node* Rule_RegexpExp_Tilde(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Regexp Exp> ::= <Shift Exp> */
Nany::Ast::Node* Rule_RegexpExp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Shift Exp> ::= <Shift Exp> '<<' <Add Exp> */
Nany::Ast::Node* Rule_ShiftExp_LtLt(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Shift Exp> ::= <Shift Exp> '>>' <Add Exp> */
Nany::Ast::Node* Rule_ShiftExp_GtGt(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Shift Exp> ::= <Add Exp> */
Nany::Ast::Node* Rule_ShiftExp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Add Exp> ::= <Add Exp> '+' <Mult Exp> */
Nany::Ast::Node* Rule_AddExp_Plus(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Add Exp> ::= <Add Exp> '-' <Mult Exp> */
Nany::Ast::Node* Rule_AddExp_Minus(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Add Exp> ::= <Mult Exp> */
Nany::Ast::Node* Rule_AddExp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Mult Exp> ::= <Mult Exp> '*' <Power Exp> */
Nany::Ast::Node* Rule_MultExp_Times(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Mult Exp> ::= <Mult Exp> '/' <Power Exp> */
Nany::Ast::Node* Rule_MultExp_Div(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Mult Exp> ::= <Power Exp> */
Nany::Ast::Node* Rule_MultExp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Power Exp> ::= <Power Exp> '^' <Negate Exp> */
Nany::Ast::Node* Rule_PowerExp_Caret(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Power Exp> ::= <Negate Exp> */
Nany::Ast::Node* Rule_PowerExp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Negate Exp> ::= '-' <Value> */
Nany::Ast::Node* Rule_NegateExp_Minus(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Negate Exp> ::= -- <Value> */
Nany::Ast::Node* Rule_NegateExp_MinusMinus(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Negate Exp> ::= '++' <Value> */
Nany::Ast::Node* Rule_NegateExp_PlusPlus(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Negate Exp> ::= <Value> -- */
Nany::Ast::Node* Rule_NegateExp_MinusMinus2(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Negate Exp> ::= <Value> '++' */
Nany::Ast::Node* Rule_NegateExp_PlusPlus2(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Negate Exp> ::= <Value> */
Nany::Ast::Node* Rule_NegateExp(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Value> ::= <Literal> <Subscript> */
Nany::Ast::Node* Rule_Value(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Value> ::= '(' <SingleThread Exp> ')' <Subscript> */
Nany::Ast::Node* Rule_Value_LParan_RParan(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Value> ::= Identifier <Subscript> */
Nany::Ast::Node* Rule_Value_Identifier(struct TokenStruct *Token, struct ContextStruct *Context)
{
	RuleTemplate(Token,Context);
	assert(Context->ReturnValue && "Identifier node must have a value !");
	Yuni::String data(Context->ReturnValue);
	return new Nany::Ast::IdentifierNode(data);
};




/* <Subscript> ::=  */
Nany::Ast::Node* Rule_Subscript(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Subscript> ::= '.' <Value> */
Nany::Ast::Node* Rule_Subscript_Dot(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/* <Subscript> ::= '(' <Argument List> ')' */
Nany::Ast::Node* Rule_Subscript_LParan_RParan(struct TokenStruct *Token, struct ContextStruct *Context)
{
	return RuleTemplate(Token,Context);
};




/***** Rule jumptable *******************************************************/




Nany::Ast::Node* (*RuleJumpTable[])(struct TokenStruct *Token, struct ContextStruct *Context) =
{

	/* 0. <Program> ::= <Unit Declaration> <Dependencies> <Implementation Block> */
	Rule_Program,

	/* 1. <Unit Declaration> ::= <Optional Visibility Qualifier> unit Identifier ';' */
	Rule_UnitDeclaration_unit_Identifier_Semi,

	/* 2. <Unit Declaration> ::= program Identifier ';' */
	Rule_UnitDeclaration_program_Identifier_Semi,

	/* 3. <Dependencies> ::= <Dependency> <Dependencies> */
	Rule_Dependencies,

	/* 4. <Dependencies> ::=  */
	Rule_Dependencies2,

	/* 5. <Dependency> ::= uses Identifier <Dependency Continued> ';' */
	Rule_Dependency_uses_Identifier_Semi,

	/* 6. <Dependency Continued> ::= '.' Identifier <Dependency Continued> */
	Rule_DependencyContinued_Dot_Identifier,

	/* 7. <Dependency Continued> ::=  */
	Rule_DependencyContinued,

	/* 8. <Implementation Block> ::= <Function Declaration> <Implementation Block> */
	Rule_ImplementationBlock,

	/* 9. <Implementation Block> ::= <Optional Visibility Qualifier> <Class Declaration> <Implementation Block> */
	Rule_ImplementationBlock2,

	/* 10. <Implementation Block> ::= <Optional Visibility Qualifier> <Workflow Declaration> <Implementation Block> */
	Rule_ImplementationBlock3,

	/* 11. <Implementation Block> ::= <Optional Visibility Qualifier> <Enum Declaration> <Implementation Block> */
	Rule_ImplementationBlock4,

	/* 12. <Implementation Block> ::=  */
	Rule_ImplementationBlock5,

	/* 13. <Literal> ::= BooleanLiteral */
	Rule_Literal_BooleanLiteral,

	/* 14. <Literal> ::= DecLiteral */
	Rule_Literal_DecLiteral,

	/* 15. <Literal> ::= HexLiteral */
	Rule_Literal_HexLiteral,

	/* 16. <Literal> ::= RealLiteral */
	Rule_Literal_RealLiteral,

	/* 17. <Literal> ::= TimeLiteral */
	Rule_Literal_TimeLiteral,

	/* 18. <Literal> ::= CharLiteral */
	Rule_Literal_CharLiteral,

	/* 19. <Literal> ::= StringLiteral */
	Rule_Literal_StringLiteral,

	/* 20. <Literal> ::= BuiltInType */
	Rule_Literal_BuiltInType,

	/* 21. <Literal> ::= nil */
	Rule_Literal_nil,

	/* 22. <Literal> ::= self */
	Rule_Literal_self,

	/* 23. <Class Declaration> ::= class Identifier <Optional Type Parameters> <In Block> <Out Block> '{' <Class Content> '}' */
	Rule_ClassDeclaration_class_Identifier_LBrace_RBrace,

	/* 24. <Class Content> ::= VisibilityQualifier <Class Content> */
	Rule_ClassContent_VisibilityQualifier,

	/* 25. <Class Content> ::= <Method Declaration> <Class Content> */
	Rule_ClassContent,

	/* 26. <Class Content> ::= <Attribute Declaration> ';' <Class Content> */
	Rule_ClassContent_Semi,

	/* 27. <Class Content> ::= <Property Declaration> ';' <Class Content> */
	Rule_ClassContent_Semi2,

	/* 28. <Class Content> ::= <Class Declaration> <Class Content> */
	Rule_ClassContent2,

	/* 29. <Class Content> ::=  */
	Rule_ClassContent3,

	/* 30. <Property Declaration> ::= property Identifier <Optional Typing> <Optional Assignment> <Property Callbacks> */
	Rule_PropertyDeclaration_property_Identifier,

	/* 31. <Property Callbacks> ::= read <SingleThread Exp> <Property Callbacks> */
	Rule_PropertyCallbacks_read,

	/* 32. <Property Callbacks> ::= write <SingleThread Exp> <Property Callbacks> */
	Rule_PropertyCallbacks_write,

	/* 33. <Property Callbacks> ::=  */
	Rule_PropertyCallbacks,

	/* 34. <Attribute Declaration> ::= attribute Identifier <Optional Typing> <Optional Assignment> */
	Rule_AttributeDeclaration_attribute_Identifier,

	/* 35. <Attribute Declaration> ::= ConstQualifier attribute Identifier <Optional Typing> <Optional Assignment> */
	Rule_AttributeDeclaration_ConstQualifier_attribute_Identifier,

	/* 36. <Optional Assignment> ::= ':=' <Expression> */
	Rule_OptionalAssignment_ColonEq,

	/* 37. <Optional Assignment> ::=  */
	Rule_OptionalAssignment,

	/* 38. <Optional Typing> ::= ':' <Type Qualifiers> <SingleThread Exp> */
	Rule_OptionalTyping_Colon,

	/* 39. <Optional Typing> ::=  */
	Rule_OptionalTyping,

	/* 40. <Workflow Declaration> ::= workflow Identifier '{' <Workflow Content> '}' */
	Rule_WorkflowDeclaration_workflow_Identifier_LBrace_RBrace,

	/* 41. <Workflow Content> ::= <State Block> <Transition Block> */
	Rule_WorkflowContent,

	/* 42. <State Block> ::= states <Workflow States> */
	Rule_StateBlock_states,

	/* 43. <State Block> ::=  */
	Rule_StateBlock,

	/* 44. <Workflow States> ::= default Identifier ';' <Workflow States> */
	Rule_WorkflowStates_default_Identifier_Semi,

	/* 45. <Workflow States> ::= state Identifier ';' <Workflow States> */
	Rule_WorkflowStates_state_Identifier_Semi,

	/* 46. <Workflow States> ::=  */
	Rule_WorkflowStates,

	/* 47. <Transition Block> ::= transitions <Workflow Transitions> */
	Rule_TransitionBlock_transitions,

	/* 48. <Transition Block> ::=  */
	Rule_TransitionBlock,

	/* 49. <Workflow Transitions> ::= default allow ';' <Workflow Transitions> */
	Rule_WorkflowTransitions_default_allow_Semi,

	/* 50. <Workflow Transitions> ::= default forbid ';' <Workflow Transitions> */
	Rule_WorkflowTransitions_default_forbid_Semi,

	/* 51. <Workflow Transitions> ::= allow <Workflow Permissions> '=>' <Workflow Permissions> ';' <Workflow Transitions> */
	Rule_WorkflowTransitions_allow_EqGt_Semi,

	/* 52. <Workflow Transitions> ::= forbid <Workflow Permissions> '=>' <Workflow Permissions> ';' <Workflow Transitions> */
	Rule_WorkflowTransitions_forbid_EqGt_Semi,

	/* 53. <Workflow Transitions> ::=  */
	Rule_WorkflowTransitions,

	/* 54. <Workflow Permission> ::= '*' */
	Rule_WorkflowPermission_Times,

	/* 55. <Workflow Permission> ::= Identifier */
	Rule_WorkflowPermission_Identifier,

	/* 56. <Workflow Permission> ::= '+' Identifier */
	Rule_WorkflowPermission_Plus_Identifier,

	/* 57. <Workflow Permission> ::= '-' Identifier */
	Rule_WorkflowPermission_Minus_Identifier,

	/* 58. <Workflow Permissions> ::= <Workflow Permission> ',' <Workflow Permissions> */
	Rule_WorkflowPermissions_Comma,

	/* 59. <Workflow Permissions> ::= <Workflow Permission> */
	Rule_WorkflowPermissions,

	/* 60. <Enum Declaration> ::= enum Identifier '{' <Enum Content> '}' */
	Rule_EnumDeclaration_enum_Identifier_LBrace_RBrace,

	/* 61. <Enum Content> ::= Identifier ',' <Enum Content> */
	Rule_EnumContent_Identifier_Comma,

	/* 62. <Enum Content> ::= Identifier */
	Rule_EnumContent_Identifier,

	/* 63. <Enum Content> ::=  */
	Rule_EnumContent,

	/* 64. <Function Declaration> ::= <Optional Optim Qualifier> function Identifier <Optional Type Parameters> <Optional Parameters> <Return Type Declaration> <In Block> <Out Block> '{' <Expression> '}' */
	Rule_FunctionDeclaration_function_Identifier_LBrace_RBrace,

	/* 65. <Method Declaration> ::= <Optional Optim Qualifier> method Identifier <Optional Type Parameters> <Optional Parameters> <Return Type Declaration> <In Block> <Out Block> '{' <Expression> '}' */
	Rule_MethodDeclaration_method_Identifier_LBrace_RBrace,

	/* 66. <Return Type Declaration> ::= ':' <Expression> */
	Rule_ReturnTypeDeclaration_Colon,

	/* 67. <Return Type Declaration> ::=  */
	Rule_ReturnTypeDeclaration,

	/* 68. <Optional Parameters> ::= '(' <Parameter List> ')' */
	Rule_OptionalParameters_LParan_RParan,

	/* 69. <Optional Parameters> ::=  */
	Rule_OptionalParameters,

	/* 70. <Parameter List> ::= Identifier <Optional Typing> <Optional Assignment> <Parameter List Continued> */
	Rule_ParameterList_Identifier,

	/* 71. <Parameter List> ::=  */
	Rule_ParameterList,

	/* 72. <Parameter List Continued> ::= ',' <Parameter List> */
	Rule_ParameterListContinued_Comma,

	/* 73. <Parameter List Continued> ::=  */
	Rule_ParameterListContinued,

	/* 74. <Type Qualifiers> ::= TypeQualifier <Type Qualifiers Continued> */
	Rule_TypeQualifiers_TypeQualifier,

	/* 75. <Type Qualifiers> ::=  */
	Rule_TypeQualifiers,

	/* 76. <Type Qualifiers Continued> ::= TypeQualifier <Type Qualifiers Continued> */
	Rule_TypeQualifiersContinued_TypeQualifier,

	/* 77. <Type Qualifiers Continued> ::=  */
	Rule_TypeQualifiersContinued,

	/* 78. <Optional Optim Qualifier> ::= OptimQualifier */
	Rule_OptionalOptimQualifier_OptimQualifier,

	/* 79. <Optional Optim Qualifier> ::=  */
	Rule_OptionalOptimQualifier,

	/* 80. <Optional Visibility Qualifier> ::= VisibilityQualifier */
	Rule_OptionalVisibilityQualifier_VisibilityQualifier,

	/* 81. <Optional Visibility Qualifier> ::=  */
	Rule_OptionalVisibilityQualifier,

	/* 82. <Argument List> ::= <Expression> <Argument List Continued> */
	Rule_ArgumentList,

	/* 83. <Argument List> ::=  */
	Rule_ArgumentList2,

	/* 84. <Argument List Continued> ::= ',' <Expression> */
	Rule_ArgumentListContinued_Comma,

	/* 85. <Argument List Continued> ::=  */
	Rule_ArgumentListContinued,

	/* 86. <In Block> ::= in <Expression> */
	Rule_InBlock_in,

	/* 87. <In Block> ::=  */
	Rule_InBlock,

	/* 88. <Out Block> ::= out <Expression> */
	Rule_OutBlock_out,

	/* 89. <Out Block> ::=  */
	Rule_OutBlock,

	/* 90. <Optional Type Parameters> ::= '<' <Type Parameters> */
	Rule_OptionalTypeParameters_Lt,

	/* 91. <Optional Type Parameters> ::=  */
	Rule_OptionalTypeParameters,

	/* 92. <Type Parameters> ::= Identifier <Type Parameters Continued> '>' */
	Rule_TypeParameters_Identifier_Gt,

	/* 93. <Type Parameters> ::= Identifier ':=' <Expression> <Type Parameters Continued> '>' */
	Rule_TypeParameters_Identifier_ColonEq_Gt,

	/* 94. <Type Parameters Continued> ::= ',' Identifier <Type Parameters Continued> */
	Rule_TypeParametersContinued_Comma_Identifier,

	/* 95. <Type Parameters Continued> ::= ',' Identifier ':=' <Expression> <Type Parameters Continued> */
	Rule_TypeParametersContinued_Comma_Identifier_ColonEq,

	/* 96. <Type Parameters Continued> ::=  */
	Rule_TypeParametersContinued,

	/* 97. <Type Arguments> ::= <Expression> <Type Arguments Continued> '>' */
	Rule_TypeArguments_Gt,

	/* 98. <Type Arguments Continued> ::= ',' <Expression> <Type Parameters Continued> */
	Rule_TypeArgumentsContinued_Comma,

	/* 99. <Type Arguments Continued> ::=  */
	Rule_TypeArgumentsContinued,

	/* 100. <Expression> ::= <Possibly Parallel Exp> <Expression List> */
	Rule_Expression,

	/* 101. <Expression List> ::= ';' <Expression> */
	Rule_ExpressionList_Semi,

	/* 102. <Expression List> ::=  */
	Rule_ExpressionList,

	/* 103. <Possibly Parallel Exp> ::= <SingleThread Exp> */
	Rule_PossiblyParallelExp,

	/* 104. <Possibly Parallel Exp> ::= '&' <SingleThread Exp> */
	Rule_PossiblyParallelExp_Amp,

	/* 105. <SingleThread Exp> ::= <Assignment Exp> */
	Rule_SingleThreadExp,

	/* 106. <Assignment Exp> ::= <Simple Exp> <Optional Typing> <Optional Assignment> */
	Rule_AssignmentExp,

	/* 107. <Simple Exp> ::= <Binary Exp> */
	Rule_SimpleExp,

	/* 108. <Simple Exp> ::= return <SingleThread Exp> */
	Rule_SimpleExp_return,

	/* 109. <Simple Exp> ::= typeof <SingleThread Exp> */
	Rule_SimpleExp_typeof,

	/* 110. <Simple Exp> ::= break */
	Rule_SimpleExp_break,

	/* 111. <Simple Exp> ::= continue */
	Rule_SimpleExp_continue,

	/* 112. <Simple Exp> ::= <Attribute Declaration> */
	Rule_SimpleExp2,

	/* 113. <Simple Exp> ::= if <Expression> then <Expression> <Else Expression> */
	Rule_SimpleExp_if_then,

	/* 114. <Simple Exp> ::= while <Expression> do <Expression> */
	Rule_SimpleExp_while_do,

	/* 115. <Simple Exp> ::= for Identifier ':=' <Expression> until <Expression> do <Expression> */
	Rule_SimpleExp_for_Identifier_ColonEq_until_do,

	/* 116. <Simple Exp> ::= for Identifier ':=' <Expression> until <Expression> step <Expression> do <Expression> */
	Rule_SimpleExp_for_Identifier_ColonEq_until_step_do,

	/* 117. <Simple Exp> ::= foreach Identifier in <Expression> do <Expression> */
	Rule_SimpleExp_foreach_Identifier_in_do,

	/* 118. <Simple Exp> ::= foreach Identifier in <Expression> order do <Expression> */
	Rule_SimpleExp_foreach_Identifier_in_order_do,

	/* 119. <Simple Exp> ::= timeout <Expression> do <Expression> */
	Rule_SimpleExp_timeout_do,

	/* 120. <Simple Exp> ::= timeout <Expression> do <Expression> else <Expression> */
	Rule_SimpleExp_timeout_do_else,

	/* 121. <Simple Exp> ::= '{' <Expression> '}' */
	Rule_SimpleExp_LBrace_RBrace,

	/* 122. <Else Expression> ::= else <Expression> */
	Rule_ElseExpression_else,

	/* 123. <Else Expression> ::=  */
	Rule_ElseExpression,

	/* 124. <Binary Exp> ::= <SingleThread Exp> '|' <Xor Exp> */
	Rule_BinaryExp_Pipe,

	/* 125. <Binary Exp> ::= <Xor Exp> */
	Rule_BinaryExp,

	/* 126. <Xor Exp> ::= <Xor Exp> xor <Or Exp> */
	Rule_XorExp_xor,

	/* 127. <Xor Exp> ::= <Or Exp> */
	Rule_XorExp,

	/* 128. <Or Exp> ::= <Or Exp> or <And Exp> */
	Rule_OrExp_or,

	/* 129. <Or Exp> ::= <And Exp> */
	Rule_OrExp,

	/* 130. <And Exp> ::= <And Exp> and <Compare Exp> */
	Rule_AndExp_and,

	/* 131. <And Exp> ::= <Equal Exp> */
	Rule_AndExp,

	/* 132. <Equal Exp> ::= <Equal Exp> '=' <Compare Exp> */
	Rule_EqualExp_Eq,

	/* 133. <Equal Exp> ::= <Equal Exp> '!=' <Compare Exp> */
	Rule_EqualExp_ExclamEq,

	/* 134. <Equal Exp> ::= <Compare Exp> */
	Rule_EqualExp,

	/* 135. <Compare Exp> ::= <Compare Exp> '>' <Regexp Exp> */
	Rule_CompareExp_Gt,

	/* 136. <Compare Exp> ::= <Compare Exp> '<=' <Regexp Exp> */
	Rule_CompareExp_LtEq,

	/* 137. <Compare Exp> ::= <Compare Exp> '>=' <Regexp Exp> */
	Rule_CompareExp_GtEq,

	/* 138. <Compare Exp> ::= <Inferior Exp> */
	Rule_CompareExp,

	/* 139. <Compare Exp> ::= <Regexp Exp> */
	Rule_CompareExp2,

	/* 140. <Inferior Exp> ::= <Compare Exp> '<' <Regexp Exp> */
	Rule_InferiorExp_Lt,

	/* 141. <Regexp Exp> ::= <Regexp Exp> '~' <Shift Exp> */
	Rule_RegexpExp_Tilde,

	/* 142. <Regexp Exp> ::= <Shift Exp> */
	Rule_RegexpExp,

	/* 143. <Shift Exp> ::= <Shift Exp> '<<' <Add Exp> */
	Rule_ShiftExp_LtLt,

	/* 144. <Shift Exp> ::= <Shift Exp> '>>' <Add Exp> */
	Rule_ShiftExp_GtGt,

	/* 145. <Shift Exp> ::= <Add Exp> */
	Rule_ShiftExp,

	/* 146. <Add Exp> ::= <Add Exp> '+' <Mult Exp> */
	Rule_AddExp_Plus,

	/* 147. <Add Exp> ::= <Add Exp> '-' <Mult Exp> */
	Rule_AddExp_Minus,

	/* 148. <Add Exp> ::= <Mult Exp> */
	Rule_AddExp,

	/* 149. <Mult Exp> ::= <Mult Exp> '*' <Power Exp> */
	Rule_MultExp_Times,

	/* 150. <Mult Exp> ::= <Mult Exp> '/' <Power Exp> */
	Rule_MultExp_Div,

	/* 151. <Mult Exp> ::= <Power Exp> */
	Rule_MultExp,

	/* 152. <Power Exp> ::= <Power Exp> '^' <Negate Exp> */
	Rule_PowerExp_Caret,

	/* 153. <Power Exp> ::= <Negate Exp> */
	Rule_PowerExp,

	/* 154. <Negate Exp> ::= '-' <Value> */
	Rule_NegateExp_Minus,

	/* 155. <Negate Exp> ::= -- <Value> */
	Rule_NegateExp_MinusMinus,

	/* 156. <Negate Exp> ::= '++' <Value> */
	Rule_NegateExp_PlusPlus,

	/* 157. <Negate Exp> ::= <Value> -- */
	Rule_NegateExp_MinusMinus2,

	/* 158. <Negate Exp> ::= <Value> '++' */
	Rule_NegateExp_PlusPlus2,

	/* 159. <Negate Exp> ::= <Value> */
	Rule_NegateExp,

	/* 160. <Value> ::= <Literal> <Subscript> */
	Rule_Value,

	/* 161. <Value> ::= '(' <SingleThread Exp> ')' <Subscript> */
	Rule_Value_LParan_RParan,

	/* 162. <Value> ::= Identifier <Subscript> */
	Rule_Value_Identifier,

	/* 163. <Subscript> ::=  */
	Rule_Subscript,

	/* 164. <Subscript> ::= '.' <Value> */
	Rule_Subscript_Dot,

	/* 165. <Subscript> ::= '(' <Argument List> ')' */
	Rule_Subscript_LParan_RParan
};



/***** Rule subroutine template *********************************************/




/* This subroutine is a template of things that can happen in the
   subroutine of a rule. It shows how to access the value of symbols
   and how to call rules, and how to transport results and stuff via
   the Context.

   For example the rule:

   <Increment> ::= <Expression> '+' Number

   Has 3 sub-tokens:

   Token->Tokens[0] = token for <Expression>, a rule
   Token->Tokens[1] = token for '+', a symbol
   Token->Tokens[2] = token for Number, a symbol

   We know Token->Tokens[0] is a rule, because that's what the grammar
   says. We may assume that the engine has fully populated the sub-tokens
   and don't have to perform any checks. We can immediately call the
   subroutine of the rule, like this:

   RuleJumpTable[Token->Tokens[0]->ReductionRule](Token->Tokens[0],Context);

   The subroutine should hand back it's results via the Context. Here
   is an example of how to store a result in the context:

   Context->ReturnValue = (wchar_t *)wcsdup(....);

   Symbols are literal strings from the input (that was parsed by the
   engine), stored in the sub-token. We can get the value of the "Number"
   symbol like this:

   Value = (wchar_t *)wcsdup(Token->Tokens[2]->Data);

   Further reading:
   - See "engine.h" for the definition of the TokenStruct.
   - See "readme.txt" for a short discussion on how to use the content
   of a Token.
   - See "example4.c" for a working template example.
*/

static Nany::Ast::Node* RuleTemplate(struct TokenStruct *Token, struct ContextStruct *Context)
{
	int i;

	/* For all the sub-Tokens. */
	for (i = 0; i < Grammar.RuleArray[Token->ReductionRule].SymbolsCount; i++)
	{
		/* See if the Token is a Symbol or a Rule. */
		if (Token->Tokens[i]->ReductionRule < 0)
		{
			/* It's a Symbol. Make a copy of the Data. Most symbols are grammar,
			   for example '+', 'function', 'while', and such, and you won't
			   need to look at the Data. Other symbols are literals from the input
			   script, for example numbers, strings, variable names, and such. */
			if (Context->ReturnValue != NULL)
				free(Context->ReturnValue);
			Context->ReturnValue = (wchar_t *)wcsdup(Token->Tokens[i]->Data);
		}
		else
		{
			/* It's a rule. */

			/* Call the rule's subroutine via the RuleJumpTable. */
			Context->Indent = Context->Indent + 1;
			RuleJumpTable[Token->Tokens[i]->ReductionRule](Token->Tokens[i],Context);
			Context->Indent = Context->Indent - 1;

			/* At this point you will probably want to save the Context->ReturnValue
			   somewhere. */
		}
	}

	/* Do whatever processing is needed by the rule. Remember to free() the
	   Values you have saved. */
	return nullptr;
}


static Nany::Ast::Node* ParseChild(struct TokenStruct* parent, struct ContextStruct* context, unsigned int index)
{
	// Make sure the child index is not out of bounds
	assert(index < (unsigned int)Grammar.RuleArray[parent->ReductionRule].SymbolsCount && "ParseChild: index out of bounds !");

	Nany::Ast::Node* result = nullptr;
	struct TokenStruct* child = parent->Tokens[index];
	// See if the Token is a Symbol or a Rule.
	if (child->ReductionRule < 0)
	{
		// It's a symbol, store it and return null
		context->ReturnValue = (wchar_t *)wcsdup(child->Data);
	}
	else
	{
		// It's a rule, call the rule's subroutine via the RuleJumpTable and return the node.
		context->Indent = context->Indent + 1;
		result = RuleJumpTable[child->ReductionRule](child, context);
		context->Indent = context->Indent - 1;
	}
	return result;
}


/***** Main *****************************************************************/




/* Load input file from disk into memory. */
static wchar_t *LoadInputFile(const char *FileName)
{
	FILE *Fin;
	char *Buf1;
	wchar_t *Buf2;
	struct stat statbuf;
	size_t BytesRead;
	unsigned long i;

	/* Sanity check. */
	if ((FileName == NULL) || (*FileName == '\0'))
		return NULL;

	/* Open the file. */
	Fin = fopen(FileName,"rb");
	if (Fin == NULL)
	{
		std::cerr << "Could not open input file: " << FileName << std::endl;
		return NULL;
	}

	/* Get the size of the file. */
	if (fstat(fileno(Fin),&statbuf) != 0)
	{
		std::cerr << "Could not stat() the input file: " << FileName << std::endl;
		fclose(Fin);
		return NULL;
	}

	/* Allocate memory for the input. */
	Buf1 = (char *)malloc(statbuf.st_size + 1);
	Buf2 = (wchar_t *)malloc(sizeof(wchar_t) * (statbuf.st_size + 1));
	if ((Buf1 == NULL) || (Buf2 == NULL))
	{
		std::cerr << "Not enough memory to load the file: " << FileName << std::endl;
		fclose(Fin);
		if (Buf1 != NULL) free(Buf1);
		if (Buf2 != NULL) free(Buf2);
		return NULL;
	}

	/* Load the file into memory. */
	BytesRead = fread(Buf1,1,statbuf.st_size,Fin);
	Buf1[BytesRead] = '\0';

	/* Close the file. */
	fclose(Fin);

	/* Exit if there was an error while reading the file. */
	if (BytesRead != (size_t)statbuf.st_size)
	{
		std::cerr << "Error while reading input file: " << FileName << std::endl;
		free(Buf1);
		free(Buf2);
		return NULL;
	}

	/* Convert from ASCII to Unicode. */
	for (i = 0; i <= BytesRead; i++)
		Buf2[i] = Buf1[i];
	free(Buf1);

	return(Buf2);
}




static void ShowErrorMessage(struct TokenStruct *Token, int Result)
{
	int Symbol;
	int i;
	wchar_t s1[BUFSIZ];

	switch(Result)
	{
		case PARSELEXICALERROR:
			std::cerr << "Lexical error";
			break;
		case PARSECOMMENTERROR:
			std::cerr << "Comment error";
			break;
		case PARSETOKENERROR:
			std::cerr << "Tokenizer error";
			break;
		case PARSESYNTAXERROR:
			std::cerr << "Syntax error";
			break;
		case PARSEMEMORYERROR:
			std::cerr << "Out of memory";
			break;
	}
	if (Token != NULL)
		std::cerr << " at line " << Token->Line << " column " << Token->Column;
	std::cerr << "." << std::endl;

	if (Result == PARSELEXICALERROR)
	{
		if (Token->Data != NULL)
		{
			ReadableString(Token->Data,s1,BUFSIZ);
			std::cerr << "The grammar does not specify what to do with '" << s1 << "'." << std::endl;
		}
		else
		{
			std::cerr << "The grammar does not specify what to do." << std::endl;
		}
	}
	if (Result == PARSETOKENERROR)
	{
		std::cerr << "The tokenizer returned a non-terminal." << std::endl;
	}
	if (Result == PARSECOMMENTERROR)
	{
		std::cerr << "The comment has no end, it was started but not finished." << std::endl;
	}
	if (Result == PARSESYNTAXERROR)
	{
		if (Token->Data != NULL)
		{
			ReadableString(Token->Data,s1,BUFSIZ);
			std::cerr << "Encountered '" << s1 << "', but expected ";
		}
		else
		{
			std::cerr << "Expected ";
		}
		for (i = 0; i < Grammar.LalrArray[Token->Symbol].ActionCount; i++)
		{
			Symbol = Grammar.LalrArray[Token->Symbol].Actions[i].Entry;
			if (Grammar.SymbolArray[Symbol].Kind == SYMBOLTERMINAL)
			{
				if (i > 0)
				{
					std::cerr << ", ";
					if (i >= Grammar.LalrArray[Token->Symbol].ActionCount - 2)
						std::cerr << "or ";
				}
				std::cerr << '\'' << Grammar.SymbolArray[Symbol].Name << '\'';
			}
		}
		std::cerr << "." << std::endl;
	}
}


Nany::Ast::Node* parseFile(const char* filePath)
{
	wchar_t* inputBuf;
	struct TokenStruct* token;
	struct ContextStruct context;
	Nany::Ast::Node* tree = nullptr;


	// Load the inputfile into memory.
	inputBuf = LoadInputFile(filePath);
	if (!inputBuf)
	{
		std::cerr << "\"" << filePath << "\" could not be opened." << std::endl;
		return tree;
	}


	// Run the Parser.
	int parseResult = Parse(inputBuf, wcslen(inputBuf), TRIMREDUCTIONS, &token);

	// Interpret the results.
	if (parseResult != PARSEACCEPT)
	{
		ShowErrorMessage(token, parseResult);
	}
	else
	{
		// Initialize the Context.
		context.Indent = 0;
		context.ReturnValue = NULL;

		// Start execution by calling the subroutine of the first Token on
		// the TokenStack. It's the "Start Symbol" that is defined in the
		// grammar.
		tree = RuleJumpTable[token->ReductionRule](token, &context);
	}

	// Cleanup.
	DeleteTokens(token);
	free(inputBuf);
	return tree;
}
